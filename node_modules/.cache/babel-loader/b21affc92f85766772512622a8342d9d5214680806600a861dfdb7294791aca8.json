{"ast":null,"code":"import { DOMLayoutDelegate as $kbsd1$DOMLayoutDelegate } from \"@react-aria/selection\";\nimport { getNthItem as $kbsd1$getNthItem, getChildNodes as $kbsd1$getChildNodes, getLastItem as $kbsd1$getLastItem, getFirstItem as $kbsd1$getFirstItem } from \"@react-stately/collections\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nclass $d1c300d9c497e402$export$de9feff04fda126e {\n  isCell(node) {\n    return node.type === 'cell';\n  }\n  isRow(node) {\n    return node.type === 'row' || node.type === 'item';\n  }\n  isDisabled(item) {\n    var _item_props;\n    return this.disabledBehavior === 'all' && (((_item_props = item.props) === null || _item_props === void 0 ? void 0 : _item_props.isDisabled) || this.disabledKeys.has(item.key));\n  }\n  findPreviousKey(fromKey, pred) {\n    let key = fromKey != null ? this.collection.getKeyBefore(fromKey) : this.collection.getLastKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!this.isDisabled(item) && (!pred || pred(item))) return key;\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n  findNextKey(fromKey, pred) {\n    let key = fromKey != null ? this.collection.getKeyAfter(fromKey) : this.collection.getFirstKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!this.isDisabled(item) && (!pred || pred(item))) return key;\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n  getKeyBelow(key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) return;\n    // If focus was on a cell, start searching from the parent row\n    if (this.isCell(startItem)) key = startItem.parentKey;\n    // Find the next item\n    key = this.findNextKey(key, item => item.type === 'item');\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the next row.\n      if (this.isCell(startItem)) {\n        let item = this.collection.getItem(key);\n        return (0, $kbsd1$getNthItem)((0, $kbsd1$getChildNodes)(item, this.collection), startItem.index).key;\n      }\n      // Otherwise, focus the next row\n      if (this.focusMode === 'row') return key;\n    }\n  }\n  getKeyAbove(key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) return;\n    // If focus is on a cell, start searching from the parent row\n    if (this.isCell(startItem)) key = startItem.parentKey;\n    // Find the previous item\n    key = this.findPreviousKey(key, item => item.type === 'item');\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the previous row.\n      if (this.isCell(startItem)) {\n        let item = this.collection.getItem(key);\n        return (0, $kbsd1$getNthItem)((0, $kbsd1$getChildNodes)(item, this.collection), startItem.index).key;\n      }\n      // Otherwise, focus the previous row\n      if (this.focusMode === 'row') return key;\n    }\n  }\n  getKeyRightOf(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return;\n    // If focus is on a row, focus the first child cell.\n    if (this.isRow(item)) {\n      let children = (0, $kbsd1$getChildNodes)(item, this.collection);\n      return this.direction === 'rtl' ? (0, $kbsd1$getLastItem)(children).key : (0, $kbsd1$getFirstItem)(children).key;\n    }\n    // If focus is on a cell, focus the next cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item)) {\n      let parent = this.collection.getItem(item.parentKey);\n      let children = (0, $kbsd1$getChildNodes)(parent, this.collection);\n      let next = this.direction === 'rtl' ? (0, $kbsd1$getNthItem)(children, item.index - 1) : (0, $kbsd1$getNthItem)(children, item.index + 1);\n      if (next) return next.key;\n      // focus row only if focusMode is set to row\n      if (this.focusMode === 'row') return item.parentKey;\n      return this.direction === 'rtl' ? this.getFirstKey(key) : this.getLastKey(key);\n    }\n  }\n  getKeyLeftOf(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return;\n    // If focus is on a row, focus the last child cell.\n    if (this.isRow(item)) {\n      let children = (0, $kbsd1$getChildNodes)(item, this.collection);\n      return this.direction === 'rtl' ? (0, $kbsd1$getFirstItem)(children).key : (0, $kbsd1$getLastItem)(children).key;\n    }\n    // If focus is on a cell, focus the previous cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item)) {\n      let parent = this.collection.getItem(item.parentKey);\n      let children = (0, $kbsd1$getChildNodes)(parent, this.collection);\n      let prev = this.direction === 'rtl' ? (0, $kbsd1$getNthItem)(children, item.index + 1) : (0, $kbsd1$getNthItem)(children, item.index - 1);\n      if (prev) return prev.key;\n      // focus row only if focusMode is set to row\n      if (this.focusMode === 'row') return item.parentKey;\n      return this.direction === 'rtl' ? this.getLastKey(key) : this.getFirstKey(key);\n    }\n  }\n  getFirstKey(key, global) {\n    let item;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) return;\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the first cell in the parent row.\n      if (this.isCell(item) && !global) {\n        let parent = this.collection.getItem(item.parentKey);\n        return (0, $kbsd1$getFirstItem)((0, $kbsd1$getChildNodes)(parent, this.collection)).key;\n      }\n    }\n    // Find the first row\n    key = this.findNextKey(null, item => item.type === 'item');\n    // If global flag is set (or if focus mode is cell), focus the first cell in the first row.\n    if (key != null && item && this.isCell(item) && global || this.focusMode === 'cell') {\n      let item = this.collection.getItem(key);\n      key = (0, $kbsd1$getFirstItem)((0, $kbsd1$getChildNodes)(item, this.collection)).key;\n    }\n    // Otherwise, focus the row itself.\n    return key;\n  }\n  getLastKey(key, global) {\n    let item;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) return;\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the last cell in the parent row.\n      if (this.isCell(item) && !global) {\n        let parent = this.collection.getItem(item.parentKey);\n        let children = (0, $kbsd1$getChildNodes)(parent, this.collection);\n        return (0, $kbsd1$getLastItem)(children).key;\n      }\n    }\n    // Find the last row\n    key = this.findPreviousKey(null, item => item.type === 'item');\n    // If global flag is set (or if focus mode is cell), focus the last cell in the last row.\n    if (key != null && item && this.isCell(item) && global || this.focusMode === 'cell') {\n      let item = this.collection.getItem(key);\n      let children = (0, $kbsd1$getChildNodes)(item, this.collection);\n      key = (0, $kbsd1$getLastItem)(children).key;\n    }\n    // Otherwise, focus the row itself.\n    return key;\n  }\n  getKeyPageAbove(key) {\n    let itemRect = this.layoutDelegate.getItemRect(key);\n    if (!itemRect) return null;\n    let pageY = Math.max(0, itemRect.y + itemRect.height - this.layoutDelegate.getVisibleRect().height);\n    while (itemRect && itemRect.y > pageY) {\n      key = this.getKeyAbove(key);\n      itemRect = this.layoutDelegate.getItemRect(key);\n    }\n    return key;\n  }\n  getKeyPageBelow(key) {\n    let itemRect = this.layoutDelegate.getItemRect(key);\n    if (!itemRect) return null;\n    let pageHeight = this.layoutDelegate.getVisibleRect().height;\n    let pageY = Math.min(this.layoutDelegate.getContentSize().height, itemRect.y + pageHeight);\n    while (itemRect && itemRect.y + itemRect.height < pageY) {\n      let nextKey = this.getKeyBelow(key);\n      // If nextKey is undefined, we've reached the last row already\n      if (nextKey == null) break;\n      itemRect = this.layoutDelegate.getItemRect(nextKey);\n      key = nextKey;\n    }\n    return key;\n  }\n  getKeyForSearch(search, fromKey) {\n    if (!this.collator) return null;\n    let collection = this.collection;\n    let key = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();\n    // If the starting key is a cell, search from its parent row.\n    let startItem = collection.getItem(key);\n    if (startItem.type === 'cell') key = startItem.parentKey;\n    let hasWrapped = false;\n    while (key != null) {\n      let item = collection.getItem(key);\n      // check row text value for match\n      if (item.textValue) {\n        let substring = item.textValue.slice(0, search.length);\n        if (this.collator.compare(substring, search) === 0) {\n          if (this.isRow(item) && this.focusMode === 'cell') return (0, $kbsd1$getFirstItem)((0, $kbsd1$getChildNodes)(item, this.collection)).key;\n          return item.key;\n        }\n      }\n      key = this.findNextKey(key, item => item.type === 'item');\n      // Wrap around when reaching the end of the collection\n      if (key == null && !hasWrapped) {\n        key = this.getFirstKey();\n        hasWrapped = true;\n      }\n    }\n    return null;\n  }\n  constructor(options) {\n    this.collection = options.collection;\n    this.disabledKeys = options.disabledKeys;\n    this.disabledBehavior = options.disabledBehavior || 'all';\n    this.direction = options.direction;\n    this.collator = options.collator;\n    this.layoutDelegate = options.layoutDelegate || (options.layout ? new $d1c300d9c497e402$var$DeprecatedLayoutDelegate(options.layout) : new (0, $kbsd1$DOMLayoutDelegate)(options.ref));\n    this.focusMode = options.focusMode || 'row';\n  }\n}\nclass $d1c300d9c497e402$var$DeprecatedLayoutDelegate {\n  getContentSize() {\n    return this.layout.getContentSize();\n  }\n  getItemRect(key) {\n    var _this_layout_getLayoutInfo;\n    return ((_this_layout_getLayoutInfo = this.layout.getLayoutInfo(key)) === null || _this_layout_getLayoutInfo === void 0 ? void 0 : _this_layout_getLayoutInfo.rect) || null;\n  }\n  getVisibleRect() {\n    return this.layout.virtualizer.visibleRect;\n  }\n  constructor(layout) {\n    this.layout = layout;\n  }\n}\nexport { $d1c300d9c497e402$export$de9feff04fda126e as GridKeyboardDelegate };","map":{"version":3,"names":["$d1c300d9c497e402$export$de9feff04fda126e","isCell","node","type","isRow","isDisabled","item","_item_props","disabledBehavior","props","disabledKeys","has","key","findPreviousKey","fromKey","pred","collection","getKeyBefore","getLastKey","getItem","findNextKey","getKeyAfter","getFirstKey","getKeyBelow","startItem","parentKey","$kbsd1$getNthItem","$kbsd1$getChildNodes","index","focusMode","getKeyAbove","getKeyRightOf","children","direction","$kbsd1$getLastItem","$kbsd1$getFirstItem","parent","next","getKeyLeftOf","prev","global","getKeyPageAbove","itemRect","layoutDelegate","getItemRect","pageY","Math","max","y","height","getVisibleRect","getKeyPageBelow","pageHeight","min","getContentSize","nextKey","getKeyForSearch","search","collator","hasWrapped","textValue","substring","slice","length","compare","constructor","options","layout","$d1c300d9c497e402$var$DeprecatedLayoutDelegate","$kbsd1$DOMLayoutDelegate","ref","_this_layout_getLayoutInfo","getLayoutInfo","rect","virtualizer","visibleRect"],"sources":["/Users/vedxpatel/cra-template-ved-jp-starter/node_modules/@react-aria/grid/dist/packages/@react-aria/grid/src/GridKeyboardDelegate.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Direction, DisabledBehavior, Key, KeyboardDelegate, LayoutDelegate, Node, Rect, RefObject, Size} from '@react-types/shared';\nimport {DOMLayoutDelegate} from '@react-aria/selection';\nimport {getChildNodes, getFirstItem, getLastItem, getNthItem} from '@react-stately/collections';\nimport {GridCollection} from '@react-types/grid';\n\nexport interface GridKeyboardDelegateOptions<C> {\n  collection: C,\n  disabledKeys: Set<Key>,\n  disabledBehavior?: DisabledBehavior,\n  ref?: RefObject<HTMLElement | null>,\n  direction: Direction,\n  collator?: Intl.Collator,\n  layoutDelegate?: LayoutDelegate,\n  /** @deprecated - Use layoutDelegate instead. */\n  layout?: DeprecatedLayout,\n  focusMode?: 'row' | 'cell'\n}\n\nexport class GridKeyboardDelegate<T, C extends GridCollection<T>> implements KeyboardDelegate {\n  collection: C;\n  protected disabledKeys: Set<Key>;\n  protected disabledBehavior: DisabledBehavior;\n  protected direction: Direction;\n  protected collator: Intl.Collator;\n  protected layoutDelegate: LayoutDelegate;\n  protected focusMode;\n\n  constructor(options: GridKeyboardDelegateOptions<C>) {\n    this.collection = options.collection;\n    this.disabledKeys = options.disabledKeys;\n    this.disabledBehavior = options.disabledBehavior || 'all';\n    this.direction = options.direction;\n    this.collator = options.collator;\n    this.layoutDelegate = options.layoutDelegate || (options.layout ? new DeprecatedLayoutDelegate(options.layout) : new DOMLayoutDelegate(options.ref));\n    this.focusMode = options.focusMode || 'row';\n  }\n\n  protected isCell(node: Node<T>) {\n    return node.type === 'cell';\n  }\n\n  protected isRow(node: Node<T>) {\n    return node.type === 'row' || node.type === 'item';\n  }\n\n  private isDisabled(item: Node<unknown>) {\n    return this.disabledBehavior === 'all' && (item.props?.isDisabled || this.disabledKeys.has(item.key));\n  }\n\n  protected findPreviousKey(fromKey?: Key, pred?: (item: Node<T>) => boolean) {\n    let key = fromKey != null\n      ? this.collection.getKeyBefore(fromKey)\n      : this.collection.getLastKey();\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!this.isDisabled(item) && (!pred || pred(item))) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  protected findNextKey(fromKey?: Key, pred?: (item: Node<T>) => boolean) {\n    let key = fromKey != null\n      ? this.collection.getKeyAfter(fromKey)\n      : this.collection.getFirstKey();\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!this.isDisabled(item) && (!pred || pred(item))) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyBelow(key: Key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) {\n      return;\n    }\n\n    // If focus was on a cell, start searching from the parent row\n    if (this.isCell(startItem)) {\n      key = startItem.parentKey;\n    }\n\n    // Find the next item\n    key = this.findNextKey(key, (item => item.type === 'item'));\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the next row.\n      if (this.isCell(startItem)) {\n        let item = this.collection.getItem(key);\n        return getNthItem(getChildNodes(item, this.collection), startItem.index).key;\n      }\n\n      // Otherwise, focus the next row\n      if (this.focusMode === 'row') {\n        return key;\n      }\n    }\n  }\n\n  getKeyAbove(key: Key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) {\n      return;\n    }\n\n    // If focus is on a cell, start searching from the parent row\n    if (this.isCell(startItem)) {\n      key = startItem.parentKey;\n    }\n\n    // Find the previous item\n    key = this.findPreviousKey(key, item => item.type === 'item');\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the previous row.\n      if (this.isCell(startItem)) {\n        let item = this.collection.getItem(key);\n        return getNthItem(getChildNodes(item, this.collection), startItem.index).key;\n      }\n\n      // Otherwise, focus the previous row\n      if (this.focusMode === 'row') {\n        return key;\n      }\n    }\n  }\n\n  getKeyRightOf(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      return;\n    }\n\n    // If focus is on a row, focus the first child cell.\n    if (this.isRow(item)) {\n      let children = getChildNodes(item, this.collection);\n      return this.direction === 'rtl'\n        ? getLastItem(children).key\n        : getFirstItem(children).key;\n    }\n\n    // If focus is on a cell, focus the next cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item)) {\n      let parent = this.collection.getItem(item.parentKey);\n      let children = getChildNodes(parent, this.collection);\n      let next = this.direction === 'rtl'\n        ? getNthItem(children, item.index - 1)\n        : getNthItem(children, item.index + 1);\n\n      if (next) {\n        return next.key;\n      }\n\n      // focus row only if focusMode is set to row\n      if (this.focusMode === 'row') {\n        return item.parentKey;\n      }\n\n      return this.direction === 'rtl' ? this.getFirstKey(key) : this.getLastKey(key);\n    }\n  }\n\n  getKeyLeftOf(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      return;\n    }\n\n    // If focus is on a row, focus the last child cell.\n    if (this.isRow(item)) {\n      let children = getChildNodes(item, this.collection);\n      return this.direction === 'rtl'\n        ? getFirstItem(children).key\n        : getLastItem(children).key;\n    }\n\n    // If focus is on a cell, focus the previous cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item)) {\n      let parent = this.collection.getItem(item.parentKey);\n      let children = getChildNodes(parent, this.collection);\n      let prev = this.direction === 'rtl'\n        ? getNthItem(children, item.index + 1)\n        : getNthItem(children, item.index - 1);\n\n      if (prev) {\n        return prev.key;\n      }\n\n      // focus row only if focusMode is set to row\n      if (this.focusMode === 'row') {\n        return item.parentKey;\n      }\n\n      return this.direction === 'rtl' ? this.getLastKey(key) : this.getFirstKey(key);\n    }\n  }\n\n  getFirstKey(key?: Key, global?: boolean) {\n    let item: Node<T>;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) {\n        return;\n      }\n\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the first cell in the parent row.\n      if (this.isCell(item) && !global) {\n        let parent = this.collection.getItem(item.parentKey);\n        return getFirstItem(getChildNodes(parent, this.collection)).key;\n      }\n    }\n\n    // Find the first row\n    key = this.findNextKey(null, item => item.type === 'item');\n\n    // If global flag is set (or if focus mode is cell), focus the first cell in the first row.\n    if ((key != null && item && this.isCell(item) && global) || this.focusMode === 'cell') {\n      let item = this.collection.getItem(key);\n      key = getFirstItem(getChildNodes(item, this.collection)).key;\n    }\n\n    // Otherwise, focus the row itself.\n    return key;\n  }\n\n  getLastKey(key?: Key, global?: boolean) {\n    let item: Node<T>;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) {\n        return;\n      }\n\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the last cell in the parent row.\n      if (this.isCell(item) && !global) {\n        let parent = this.collection.getItem(item.parentKey);\n        let children = getChildNodes(parent, this.collection);\n        return getLastItem(children).key;\n      }\n    }\n\n    // Find the last row\n    key = this.findPreviousKey(null, item => item.type === 'item');\n\n    // If global flag is set (or if focus mode is cell), focus the last cell in the last row.\n    if ((key != null && item && this.isCell(item) && global) || this.focusMode === 'cell') {\n      let item = this.collection.getItem(key);\n      let children = getChildNodes(item, this.collection);\n      key = getLastItem(children).key;\n    }\n\n    // Otherwise, focus the row itself.\n    return key;\n  }\n\n  getKeyPageAbove(key: Key) {\n    let itemRect = this.layoutDelegate.getItemRect(key);\n    if (!itemRect) {\n      return null;\n    }\n\n    let pageY = Math.max(0, itemRect.y + itemRect.height - this.layoutDelegate.getVisibleRect().height);\n\n    while (itemRect && itemRect.y > pageY) {\n      key = this.getKeyAbove(key);\n      itemRect = this.layoutDelegate.getItemRect(key);\n    }\n\n    return key;\n  }\n\n  getKeyPageBelow(key: Key) {\n    let itemRect = this.layoutDelegate.getItemRect(key);\n\n    if (!itemRect) {\n      return null;\n    }\n\n    let pageHeight = this.layoutDelegate.getVisibleRect().height;\n    let pageY = Math.min(this.layoutDelegate.getContentSize().height, itemRect.y + pageHeight);\n\n    while (itemRect && (itemRect.y + itemRect.height) < pageY) {\n      let nextKey = this.getKeyBelow(key);\n      // If nextKey is undefined, we've reached the last row already\n      if (nextKey == null) {\n        break;\n      }\n\n      itemRect = this.layoutDelegate.getItemRect(nextKey);\n      key = nextKey;\n    }\n\n    return key;\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey ?? this.getFirstKey();\n\n    // If the starting key is a cell, search from its parent row.\n    let startItem = collection.getItem(key);\n    if (startItem.type === 'cell') {\n      key = startItem.parentKey;\n    }\n\n    let hasWrapped = false;\n    while (key != null) {\n      let item = collection.getItem(key);\n\n      // check row text value for match\n      if (item.textValue) {\n        let substring = item.textValue.slice(0, search.length);\n        if (this.collator.compare(substring, search) === 0) {\n          if (this.isRow(item) && this.focusMode === 'cell') {\n            return getFirstItem(getChildNodes(item, this.collection)).key;\n          }\n\n          return item.key;\n        }\n      }\n\n      key = this.findNextKey(key, item => item.type === 'item');\n\n      // Wrap around when reaching the end of the collection\n      if (key == null && !hasWrapped) {\n        key = this.getFirstKey();\n        hasWrapped = true;\n      }\n    }\n\n    return null;\n  }\n}\n\n/* Backward compatibility for old Virtualizer Layout interface. */\ninterface DeprecatedLayout {\n  getLayoutInfo(key: Key): DeprecatedLayoutInfo,\n  getContentSize(): Size,\n  virtualizer: DeprecatedVirtualizer\n}\n\ninterface DeprecatedLayoutInfo {\n  rect: Rect\n}\n\ninterface DeprecatedVirtualizer {\n  visibleRect: Rect\n}\n\nclass DeprecatedLayoutDelegate implements LayoutDelegate {\n  layout: DeprecatedLayout;\n\n  constructor(layout: DeprecatedLayout) {\n    this.layout = layout;\n  }\n\n  getContentSize(): Size {\n    return this.layout.getContentSize();\n  }\n\n  getItemRect(key: Key): Rect | null {\n    return this.layout.getLayoutInfo(key)?.rect || null;\n  }\n\n  getVisibleRect(): Rect {\n    return this.layout.virtualizer.visibleRect;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}