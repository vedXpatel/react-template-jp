{"ast":null,"code":"import { calculatePosition as $edcf132a9284368a$export$b3ceb0cbf1056d98 } from \"./calculatePosition.mjs\";\nimport { useCloseOnScroll as $dd149f63282afbbf$export$18fc8428861184da } from \"./useCloseOnScroll.mjs\";\nimport { useState as $39EOa$useState, useRef as $39EOa$useRef, useEffect as $39EOa$useEffect, useCallback as $39EOa$useCallback } from \"react\";\nimport { useLayoutEffect as $39EOa$useLayoutEffect, useResizeObserver as $39EOa$useResizeObserver } from \"@react-aria/utils\";\nimport { useLocale as $39EOa$useLocale } from \"@react-aria/i18n\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// @ts-ignore\nlet $2a41e45df1593e64$var$visualViewport = typeof document !== 'undefined' && window.visualViewport;\nfunction $2a41e45df1593e64$export$d39e1813b3bdd0e1(props) {\n  let {\n    direction: direction\n  } = (0, $39EOa$useLocale)();\n  let {\n    arrowSize = 0,\n    targetRef: targetRef,\n    overlayRef: overlayRef,\n    scrollRef = overlayRef,\n    placement = 'bottom',\n    containerPadding = 12,\n    shouldFlip = true,\n    boundaryElement = typeof document !== 'undefined' ? document.body : null,\n    offset = 0,\n    crossOffset = 0,\n    shouldUpdatePosition = true,\n    isOpen = true,\n    onClose: onClose,\n    maxHeight: maxHeight,\n    arrowBoundaryOffset = 0\n  } = props;\n  let [position, setPosition] = (0, $39EOa$useState)({\n    position: {},\n    arrowOffsetLeft: undefined,\n    arrowOffsetTop: undefined,\n    maxHeight: undefined,\n    placement: undefined\n  });\n  let deps = [shouldUpdatePosition, placement, overlayRef.current, targetRef.current, scrollRef.current, containerPadding, shouldFlip, boundaryElement, offset, crossOffset, isOpen, direction, maxHeight, arrowBoundaryOffset, arrowSize];\n  // Note, the position freezing breaks if body sizes itself dynamicly with the visual viewport but that might\n  // just be a non-realistic use case\n  // Upon opening a overlay, record the current visual viewport scale so we can freeze the overlay styles\n  let lastScale = (0, $39EOa$useRef)($2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.scale);\n  (0, $39EOa$useEffect)(() => {\n    if (isOpen) lastScale.current = $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.scale;\n  }, [isOpen]);\n  let updatePosition = (0, $39EOa$useCallback)(() => {\n    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !boundaryElement) return;\n    if (($2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.scale) !== lastScale.current) return;\n    // Determine a scroll anchor based on the focused element.\n    // This stores the offset of the anchor element from the scroll container\n    // so it can be restored after repositioning. This way if the overlay height\n    // changes, the focused element appears to stay in the same position.\n    let anchor = null;\n    if (scrollRef.current && scrollRef.current.contains(document.activeElement)) {\n      let anchorRect = document.activeElement.getBoundingClientRect();\n      let scrollRect = scrollRef.current.getBoundingClientRect();\n      // Anchor from the top if the offset is in the top half of the scrollable element,\n      // otherwise anchor from the bottom.\n      anchor = {\n        type: 'top',\n        offset: anchorRect.top - scrollRect.top\n      };\n      if (anchor.offset > scrollRect.height / 2) {\n        anchor.type = 'bottom';\n        anchor.offset = anchorRect.bottom - scrollRect.bottom;\n      }\n    }\n    // Always reset the overlay's previous max height if not defined by the user so that we can compensate for\n    // RAC collections populating after a second render and properly set a correct max height + positioning when it populates.\n    let overlay = overlayRef.current;\n    if (!maxHeight && overlayRef.current) {\n      var _window_visualViewport;\n      overlay.style.top = '0px';\n      overlay.style.bottom = '';\n      var _window_visualViewport_height;\n      overlay.style.maxHeight = ((_window_visualViewport_height = (_window_visualViewport = window.visualViewport) === null || _window_visualViewport === void 0 ? void 0 : _window_visualViewport.height) !== null && _window_visualViewport_height !== void 0 ? _window_visualViewport_height : window.innerHeight) + 'px';\n    }\n    let position = (0, $edcf132a9284368a$export$b3ceb0cbf1056d98)({\n      placement: $2a41e45df1593e64$var$translateRTL(placement, direction),\n      overlayNode: overlayRef.current,\n      targetNode: targetRef.current,\n      scrollNode: scrollRef.current || overlayRef.current,\n      padding: containerPadding,\n      shouldFlip: shouldFlip,\n      boundaryElement: boundaryElement,\n      offset: offset,\n      crossOffset: crossOffset,\n      maxHeight: maxHeight,\n      arrowSize: arrowSize,\n      arrowBoundaryOffset: arrowBoundaryOffset\n    });\n    // Modify overlay styles directly so positioning happens immediately without the need of a second render\n    // This is so we don't have to delay autoFocus scrolling or delay applying preventScroll for popovers\n    overlay.style.top = '';\n    overlay.style.bottom = '';\n    overlay.style.left = '';\n    overlay.style.right = '';\n    Object.keys(position.position).forEach(key => overlay.style[key] = position.position[key] + 'px');\n    overlay.style.maxHeight = position.maxHeight != null ? position.maxHeight + 'px' : undefined;\n    // Restore scroll position relative to anchor element.\n    if (anchor) {\n      let anchorRect = document.activeElement.getBoundingClientRect();\n      let scrollRect = scrollRef.current.getBoundingClientRect();\n      let newOffset = anchorRect[anchor.type] - scrollRect[anchor.type];\n      scrollRef.current.scrollTop += newOffset - anchor.offset;\n    }\n    // Trigger a set state for a second render anyway for arrow positioning\n    setPosition(position);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n  // Update position when anything changes\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  (0, $39EOa$useLayoutEffect)(updatePosition, deps);\n  // Update position on window resize\n  $2a41e45df1593e64$var$useResize(updatePosition);\n  // Update position when the overlay changes size (might need to flip).\n  (0, $39EOa$useResizeObserver)({\n    ref: overlayRef,\n    onResize: updatePosition\n  });\n  // Update position when the target changes size (might need to flip).\n  (0, $39EOa$useResizeObserver)({\n    ref: targetRef,\n    onResize: updatePosition\n  });\n  // Reposition the overlay and do not close on scroll while the visual viewport is resizing.\n  // This will ensure that overlays adjust their positioning when the iOS virtual keyboard appears.\n  let isResizing = (0, $39EOa$useRef)(false);\n  (0, $39EOa$useLayoutEffect)(() => {\n    let timeout;\n    let onResize = () => {\n      isResizing.current = true;\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        isResizing.current = false;\n      }, 500);\n      updatePosition();\n    };\n    // Only reposition the overlay if a scroll event happens immediately as a result of resize (aka the virtual keyboard has appears)\n    // We don't want to reposition the overlay if the user has pinch zoomed in and is scrolling the viewport around.\n    let onScroll = () => {\n      if (isResizing.current) onResize();\n    };\n    $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.addEventListener('resize', onResize);\n    $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.addEventListener('scroll', onScroll);\n    return () => {\n      $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.removeEventListener('resize', onResize);\n      $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.removeEventListener('scroll', onScroll);\n    };\n  }, [updatePosition]);\n  let close = (0, $39EOa$useCallback)(() => {\n    if (!isResizing.current) onClose();\n  }, [onClose, isResizing]);\n  // When scrolling a parent scrollable region of the trigger (other than the body),\n  // we hide the popover. Otherwise, its position would be incorrect.\n  (0, $dd149f63282afbbf$export$18fc8428861184da)({\n    triggerRef: targetRef,\n    isOpen: isOpen,\n    onClose: onClose && close\n  });\n  var _position_maxHeight;\n  return {\n    overlayProps: {\n      style: {\n        position: 'absolute',\n        zIndex: 100000,\n        ...position.position,\n        maxHeight: (_position_maxHeight = position.maxHeight) !== null && _position_maxHeight !== void 0 ? _position_maxHeight : '100vh'\n      }\n    },\n    placement: position.placement,\n    arrowProps: {\n      'aria-hidden': 'true',\n      role: 'presentation',\n      style: {\n        left: position.arrowOffsetLeft,\n        top: position.arrowOffsetTop\n      }\n    },\n    updatePosition: updatePosition\n  };\n}\nfunction $2a41e45df1593e64$var$useResize(onResize) {\n  (0, $39EOa$useLayoutEffect)(() => {\n    window.addEventListener('resize', onResize, false);\n    return () => {\n      window.removeEventListener('resize', onResize, false);\n    };\n  }, [onResize]);\n}\nfunction $2a41e45df1593e64$var$translateRTL(position, direction) {\n  if (direction === 'rtl') return position.replace('start', 'right').replace('end', 'left');\n  return position.replace('start', 'left').replace('end', 'right');\n}\nexport { $2a41e45df1593e64$export$d39e1813b3bdd0e1 as useOverlayPosition };","map":{"version":3,"names":["$2a41e45df1593e64$var$visualViewport","document","window","visualViewport","$2a41e45df1593e64$export$d39e1813b3bdd0e1","props","direction","$39EOa$useLocale","arrowSize","targetRef","overlayRef","scrollRef","placement","containerPadding","shouldFlip","boundaryElement","body","offset","crossOffset","shouldUpdatePosition","isOpen","onClose","maxHeight","arrowBoundaryOffset","position","setPosition","$39EOa$useState","arrowOffsetLeft","undefined","arrowOffsetTop","deps","current","lastScale","$39EOa$useRef","scale","$39EOa$useEffect","updatePosition","$39EOa$useCallback","anchor","contains","activeElement","anchorRect","getBoundingClientRect","scrollRect","type","top","height","bottom","overlay","_window_visualViewport","style","_window_visualViewport_height","innerHeight","$edcf132a9284368a$export$b3ceb0cbf1056d98","$2a41e45df1593e64$var$translateRTL","overlayNode","targetNode","scrollNode","padding","left","right","Object","keys","forEach","key","newOffset","scrollTop","$39EOa$useLayoutEffect","$2a41e45df1593e64$var$useResize","$39EOa$useResizeObserver","ref","onResize","isResizing","timeout","clearTimeout","setTimeout","onScroll","addEventListener","removeEventListener","close","$dd149f63282afbbf$export$18fc8428861184da","triggerRef","_position_maxHeight","overlayProps","zIndex","arrowProps","role","replace"],"sources":["/Users/vedxpatel/cra-template-ved-jp-starter/node_modules/@react-aria/dialog/node_modules/@react-aria/overlays/dist/packages/@react-aria/overlays/src/useOverlayPosition.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {calculatePosition, PositionResult} from './calculatePosition';\nimport {DOMAttributes, RefObject} from '@react-types/shared';\nimport {Placement, PlacementAxis, PositionProps} from '@react-types/overlays';\nimport {useCallback, useEffect, useRef, useState} from 'react';\nimport {useCloseOnScroll} from './useCloseOnScroll';\nimport {useLayoutEffect, useResizeObserver} from '@react-aria/utils';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface AriaPositionProps extends PositionProps {\n  /**\n   * Cross size of the overlay arrow in pixels.\n   * @default 0\n   */\n  arrowSize?: number,\n  /**\n   * Element that that serves as the positioning boundary.\n   * @default document.body\n   */\n  boundaryElement?: Element,\n  /**\n   * The ref for the element which the overlay positions itself with respect to.\n   */\n  targetRef: RefObject<Element | null>,\n  /**\n   * The ref for the overlay element.\n   */\n  overlayRef: RefObject<Element | null>,\n  /**\n   * A ref for the scrollable region within the overlay.\n   * @default overlayRef\n   */\n  scrollRef?: RefObject<Element | null>,\n  /**\n   * Whether the overlay should update its position automatically.\n   * @default true\n   */\n  shouldUpdatePosition?: boolean,\n  /** Handler that is called when the overlay should close. */\n  onClose?: () => void,\n  /**\n   * The maxHeight specified for the overlay element.\n   * By default, it will take all space up to the current viewport height.\n   */\n  maxHeight?: number,\n  /**\n   * The minimum distance the arrow's edge should be from the edge of the overlay element.\n   * @default 0\n   */\n  arrowBoundaryOffset?: number\n}\n\nexport interface PositionAria {\n  /** Props for the overlay container element. */\n  overlayProps: DOMAttributes,\n  /** Props for the overlay tip arrow if any. */\n  arrowProps: DOMAttributes,\n  /** Placement of the overlay with respect to the overlay trigger. */\n  placement: PlacementAxis,\n  /** Updates the position of the overlay. */\n  updatePosition(): void\n}\n\ninterface ScrollAnchor {\n  type: 'top' | 'bottom',\n  offset: number\n}\n\n// @ts-ignore\nlet visualViewport = typeof document !== 'undefined' && window.visualViewport;\n\n/**\n * Handles positioning overlays like popovers and menus relative to a trigger\n * element, and updating the position when the window resizes.\n */\nexport function useOverlayPosition(props: AriaPositionProps): PositionAria {\n  let {direction} = useLocale();\n  let {\n    arrowSize = 0,\n    targetRef,\n    overlayRef,\n    scrollRef = overlayRef,\n    placement = 'bottom' as Placement,\n    containerPadding = 12,\n    shouldFlip = true,\n    boundaryElement = typeof document !== 'undefined' ? document.body : null,\n    offset = 0,\n    crossOffset = 0,\n    shouldUpdatePosition = true,\n    isOpen = true,\n    onClose,\n    maxHeight,\n    arrowBoundaryOffset = 0\n  } = props;\n  let [position, setPosition] = useState<PositionResult>({\n    position: {},\n    arrowOffsetLeft: undefined,\n    arrowOffsetTop: undefined,\n    maxHeight: undefined,\n    placement: undefined\n  });\n\n  let deps = [\n    shouldUpdatePosition,\n    placement,\n    overlayRef.current,\n    targetRef.current,\n    scrollRef.current,\n    containerPadding,\n    shouldFlip,\n    boundaryElement,\n    offset,\n    crossOffset,\n    isOpen,\n    direction,\n    maxHeight,\n    arrowBoundaryOffset,\n    arrowSize\n  ];\n\n  // Note, the position freezing breaks if body sizes itself dynamicly with the visual viewport but that might\n  // just be a non-realistic use case\n  // Upon opening a overlay, record the current visual viewport scale so we can freeze the overlay styles\n  let lastScale = useRef(visualViewport?.scale);\n  useEffect(() => {\n    if (isOpen) {\n      lastScale.current = visualViewport?.scale;\n    }\n  }, [isOpen]);\n\n  let updatePosition = useCallback(() => {\n    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !boundaryElement) {\n      return;\n    }\n\n    if (visualViewport?.scale !== lastScale.current) {\n      return;\n    }\n\n    // Determine a scroll anchor based on the focused element.\n    // This stores the offset of the anchor element from the scroll container\n    // so it can be restored after repositioning. This way if the overlay height\n    // changes, the focused element appears to stay in the same position.\n    let anchor: ScrollAnchor | null = null;\n    if (scrollRef.current && scrollRef.current.contains(document.activeElement)) {\n      let anchorRect = document.activeElement.getBoundingClientRect();\n      let scrollRect = scrollRef.current.getBoundingClientRect();\n      // Anchor from the top if the offset is in the top half of the scrollable element,\n      // otherwise anchor from the bottom.\n      anchor = {\n        type: 'top',\n        offset: anchorRect.top - scrollRect.top\n      };\n      if (anchor.offset > scrollRect.height / 2) {\n        anchor.type = 'bottom';\n        anchor.offset = anchorRect.bottom - scrollRect.bottom;\n      }\n    }\n\n    // Always reset the overlay's previous max height if not defined by the user so that we can compensate for\n    // RAC collections populating after a second render and properly set a correct max height + positioning when it populates.\n    let overlay = (overlayRef.current as HTMLElement);\n    if (!maxHeight && overlayRef.current) {\n      overlay.style.top = '0px';\n      overlay.style.bottom = '';\n      overlay.style.maxHeight = (window.visualViewport?.height ?? window.innerHeight) + 'px';\n    }\n\n    let position = calculatePosition({\n      placement: translateRTL(placement, direction),\n      overlayNode: overlayRef.current,\n      targetNode: targetRef.current,\n      scrollNode: scrollRef.current || overlayRef.current,\n      padding: containerPadding,\n      shouldFlip,\n      boundaryElement,\n      offset,\n      crossOffset,\n      maxHeight,\n      arrowSize,\n      arrowBoundaryOffset\n    });\n\n    // Modify overlay styles directly so positioning happens immediately without the need of a second render\n    // This is so we don't have to delay autoFocus scrolling or delay applying preventScroll for popovers\n    overlay.style.top = '';\n    overlay.style.bottom = '';\n    overlay.style.left = '';\n    overlay.style.right = '';\n\n    Object.keys(position.position).forEach(key => overlay.style[key] = position.position[key] + 'px');\n    overlay.style.maxHeight = position.maxHeight != null ?  position.maxHeight + 'px' : undefined;\n\n    // Restore scroll position relative to anchor element.\n    if (anchor) {\n      let anchorRect = document.activeElement.getBoundingClientRect();\n      let scrollRect = scrollRef.current.getBoundingClientRect();\n      let newOffset = anchorRect[anchor.type] - scrollRect[anchor.type];\n      scrollRef.current.scrollTop += newOffset - anchor.offset;\n    }\n\n    // Trigger a set state for a second render anyway for arrow positioning\n    setPosition(position);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n\n  // Update position when anything changes\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useLayoutEffect(updatePosition, deps);\n\n  // Update position on window resize\n  useResize(updatePosition);\n\n  // Update position when the overlay changes size (might need to flip).\n  useResizeObserver({\n    ref: overlayRef,\n    onResize: updatePosition\n  });\n\n  // Update position when the target changes size (might need to flip).\n  useResizeObserver({\n    ref: targetRef,\n    onResize: updatePosition\n  });\n\n  // Reposition the overlay and do not close on scroll while the visual viewport is resizing.\n  // This will ensure that overlays adjust their positioning when the iOS virtual keyboard appears.\n  let isResizing = useRef(false);\n  useLayoutEffect(() => {\n    let timeout: ReturnType<typeof setTimeout>;\n    let onResize = () => {\n      isResizing.current = true;\n      clearTimeout(timeout);\n\n      timeout = setTimeout(() => {\n        isResizing.current = false;\n      }, 500);\n\n      updatePosition();\n    };\n\n    // Only reposition the overlay if a scroll event happens immediately as a result of resize (aka the virtual keyboard has appears)\n    // We don't want to reposition the overlay if the user has pinch zoomed in and is scrolling the viewport around.\n    let onScroll = () => {\n      if (isResizing.current) {\n        onResize();\n      }\n    };\n\n    visualViewport?.addEventListener('resize', onResize);\n    visualViewport?.addEventListener('scroll', onScroll);\n    return () => {\n      visualViewport?.removeEventListener('resize', onResize);\n      visualViewport?.removeEventListener('scroll', onScroll);\n    };\n  }, [updatePosition]);\n\n  let close = useCallback(() => {\n    if (!isResizing.current) {\n      onClose();\n    }\n  }, [onClose, isResizing]);\n\n  // When scrolling a parent scrollable region of the trigger (other than the body),\n  // we hide the popover. Otherwise, its position would be incorrect.\n  useCloseOnScroll({\n    triggerRef: targetRef,\n    isOpen,\n    onClose: onClose && close\n  });\n\n  return {\n    overlayProps: {\n      style: {\n        position: 'absolute',\n        zIndex: 100000, // should match the z-index in ModalTrigger\n        ...position.position,\n        maxHeight: position.maxHeight ?? '100vh'\n      }\n    },\n    placement: position.placement,\n    arrowProps: {\n      'aria-hidden': 'true',\n      role: 'presentation',\n      style: {\n        left: position.arrowOffsetLeft,\n        top: position.arrowOffsetTop\n      }\n    },\n    updatePosition\n  };\n}\n\nfunction useResize(onResize) {\n  useLayoutEffect(() => {\n    window.addEventListener('resize', onResize, false);\n    return () => {\n      window.removeEventListener('resize', onResize, false);\n    };\n  }, [onResize]);\n}\n\nfunction translateRTL(position, direction) {\n  if (direction === 'rtl') {\n    return position.replace('start', 'right').replace('end', 'left');\n  }\n  return position.replace('start', 'left').replace('end', 'right');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}