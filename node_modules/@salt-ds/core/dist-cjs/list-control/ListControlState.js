'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
require('react/jsx-runtime');
require('clsx');
var useControlled = require('../utils/useControlled.js');
require('../utils/useFloatingUI/useFloatingUI.js');
require('../utils/useId.js');
require('../salt-provider/SaltProvider.js');
require('../viewport/ViewportProvider.js');
require('../accordion/AccordionGroup.js');
require('../accordion/AccordionPanel.js');
require('../accordion/Accordion.js');
require('../accordion/AccordionHeader.js');
require('../aria-announcer/AriaAnnouncerContext.js');
require('../avatar/Avatar.js');
require('../badge/Badge.js');
require('../banner/Banner.js');
require('../banner/BannerActions.js');
require('../banner/BannerContent.js');
require('../border-item/BorderItem.js');
require('../border-layout/BorderLayout.js');
require('../breakpoints/BreakpointProvider.js');
require('../button/Button.js');
require('../card/Card.js');
require('../checkbox/Checkbox.js');
require('../checkbox/CheckboxGroup.js');
require('@salt-ds/icons');
require('@salt-ds/styles');
require('@salt-ds/window');
require('../combo-box/ComboBox.js');
require('../dialog/Dialog.js');
require('../dialog/DialogHeader.js');
require('../dialog/DialogActions.js');
require('../dialog/DialogContent.js');
require('../dialog/DialogContext.js');
require('../dialog/DialogCloseButton.js');
require('../divider/Divider.js');
require('../drawer/Drawer.js');
require('../drawer/DrawerCloseButton.js');
require('../dropdown/Dropdown.js');
require('../file-drop-zone/FileDropZone.js');
require('../file-drop-zone/FileDropZoneIcon.js');
require('../file-drop-zone/FileDropZoneTrigger.js');
require('../flex-item/FlexItem.js');
require('../flex-layout/FlexLayout.js');
require('../flow-layout/FlowLayout.js');
require('../form-field/FormField.js');
require('../form-field-context/FormFieldContext.js');
require('../status-indicator/StatusIndicator.js');
require('../text/Text.js');
require('../text/Code.js');
require('../text/Display.js');
require('../text/Headings.js');
require('../text/Label.js');
require('../text/TextAction.js');
require('../text/TextNotation.js');
require('../grid-item/GridItem.js');
require('../grid-layout/GridLayout.js');
require('../input/Input.js');
require('../interactable-card/InteractableCard.js');
require('../interactable-card/InteractableCardGroup.js');
require('../interactable-card/InteractableCardGroupContext.js');
require('../link/Link.js');
require('../link-card/LinkCard.js');
require('../list-box/ListBox.js');
require('./ListControlContext.js');
require('@floating-ui/react');
require('../menu/MenuContext.js');
require('../menu/MenuItem.js');
require('../menu/MenuPanel.js');
require('../menu/MenuPanelContext.js');
require('../menu/MenuTriggerContext.js');
require('../menu/MenuGroup.js');
require('../multiline-input/MultilineInput.js');
require('../navigation-item/NavigationItem.js');
require('../option/Option.js');
require('../option/OptionGroup.js');
require('../overlay/OverlayContext.js');
require('../overlay/OverlayPanel.js');
require('../overlay/OverlayPanelCloseButton.js');
require('../overlay/OverlayPanelContent.js');
require('../pagination/Pagination.js');
require('../pagination/Paginator.js');
require('../pagination/CompactInput.js');
require('../pagination/CompactPaginator.js');
require('../pagination/GoToInput.js');
require('../panel/Panel.js');
require('../parent-child-layout/ParentChildLayout.js');
require('../pill/Pill.js');
require('../progress/CircularProgress/CircularProgress.js');
require('../progress/LinearProgress/LinearProgress.js');
require('../radio-button/RadioButton.js');
require('../radio-button/RadioButtonGroup.js');
require('../scrim/Scrim.js');
require('../segmented-button-group/SegmentedButtonGroup.js');
require('../spinner/Spinner.js');
require('../stack-layout/StackLayout.js');
require('../status-adornment/StatusAdornment.js');
require('../toast/Toast.js');
require('../toast/ToastContent.js');
require('../split-layout/SplitLayout.js');
require('../switch/Switch.js');
require('../tag/Tag.js');
require('../toggle-button/ToggleButton.js');
require('../toggle-button-group/ToggleButtonGroup.js');
require('../toggle-button-group/ToggleButtonGroupContext.js');
require('../tooltip/Tooltip.js');
require('../semantic-icon-provider/SemanticIconProvider.js');

function findElementPosition(elements, element) {
  if (elements.length === 0) {
    return [0, false];
  }
  if (element.compareDocumentPosition(elements[elements.length - 1].element) & Node.DOCUMENT_POSITION_PRECEDING) {
    return [-1, false];
  }
  if (element.compareDocumentPosition(elements[0].element) & Node.DOCUMENT_POSITION_FOLLOWING) {
    return [0, false];
  }
  let left = 0;
  let right = elements.length;
  let leftLast = 0;
  let rightLast = right;
  let exists = false;
  while (left < right) {
    const inPos = Math.floor((right + left) / 2);
    const compared = element.compareDocumentPosition(elements[inPos].element);
    if (compared & Node.DOCUMENT_POSITION_PRECEDING) {
      left = inPos;
    } else if (compared & Node.DOCUMENT_POSITION_FOLLOWING) {
      right = inPos;
    } else {
      right = inPos;
      left = inPos;
      exists = true;
    }
    if (leftLast === left && rightLast === right) {
      break;
    }
    leftLast = left;
    rightLast = right;
  }
  return [right, exists];
}
function defaultValueToString(item) {
  return String(item);
}
function useListControl(props) {
  const {
    open: openProp,
    defaultOpen,
    onOpenChange,
    multiselect,
    defaultSelected,
    selected: selectedProp,
    onSelectionChange,
    disabled,
    readOnly,
    valueToString = defaultValueToString
  } = props;
  const [focusedState, setFocusedState] = React.useState(false);
  const [focusVisibleState, setFocusVisibleState] = React.useState(false);
  React.useEffect(() => {
    if (disabled && focusedState) {
      setFocusedState(false);
      setFocusVisibleState(false);
    }
  }, [disabled, focusedState]);
  const [activeState, setActiveState] = React.useState(
    void 0
  );
  const setActive = (option) => {
    if (option) {
      setActiveState(option);
    } else {
      setActiveState(void 0);
    }
  };
  const [openState, setOpenState] = useControlled.useControlled({
    controlled: openProp,
    default: Boolean(defaultOpen),
    name: "ListControl",
    state: "open"
  });
  const openKey = React.useRef(void 0);
  const setOpen = (newOpen, reason, key) => {
    if (disabled || readOnly) {
      return;
    }
    setOpenState(newOpen);
    openKey.current = key;
    if (newOpen !== openState) {
      onOpenChange == null ? void 0 : onOpenChange(newOpen, reason);
    }
  };
  const [selectedState, setSelectedState] = useControlled.useControlled({
    controlled: selectedProp,
    default: defaultSelected != null ? defaultSelected : [],
    name: "ListControl",
    state: "selected"
  });
  const select = (event, option) => {
    if (option.disabled || readOnly || disabled) {
      return;
    }
    let newSelected = [option.value];
    if (multiselect) {
      if (selectedState.includes(option.value)) {
        newSelected = selectedState.filter((item) => item !== option.value);
      } else {
        newSelected = selectedState.concat([option.value]);
      }
    }
    setSelectedState(newSelected);
    onSelectionChange == null ? void 0 : onSelectionChange(event, newSelected);
    if (!multiselect) {
      setOpen(false);
    }
  };
  const clear = (event) => {
    setSelectedState([]);
    if (selectedState.length !== 0) {
      onSelectionChange == null ? void 0 : onSelectionChange(event, []);
    }
  };
  const optionsRef = React.useRef([]);
  const register = React.useCallback(
    (optionValue, element) => {
      const { id } = optionValue;
      const [index, exists] = findElementPosition(optionsRef.current, element);
      if (!exists) {
        if (index === -1) {
          optionsRef.current.push({ data: optionValue, element });
        } else {
          optionsRef.current.splice(index, 0, { data: optionValue, element });
        }
      }
      return () => {
        optionsRef.current = optionsRef.current.filter(
          (item) => item.data.id !== id
        );
      };
    },
    []
  );
  const getOptionAtIndex = (index) => {
    return optionsRef.current[index];
  };
  const getIndexOfOption = (option) => {
    return optionsRef.current.findIndex((item) => item.data.id === option.id);
  };
  const getOptionsMatching = (predicate) => {
    return optionsRef.current.filter((item) => predicate(item.data));
  };
  const getOptionFromSearch = (search, startFrom) => {
    const collator = new Intl.Collator("en", {
      usage: "search",
      sensitivity: "base"
    });
    const startIndex = startFrom ? getIndexOfOption(startFrom) + 1 : 0;
    const searchList = optionsRef.current.map((item) => item.data);
    let matches = searchList.filter(
      (option) => collator.compare(
        valueToString(option.value).substring(0, search.length),
        search
      ) === 0
    );
    if (matches.length === 0) {
      const letters = search.split("");
      const allSameLetter = letters.length > 0 && letters.every((letter) => collator.compare(letter, letters[0]) === 0);
      if (allSameLetter) {
        matches = searchList.filter(
          (option) => collator.compare(
            valueToString(option.value)[0].toLowerCase(),
            letters[0]
          ) === 0
        );
      }
    }
    return matches.find((option) => getIndexOfOption(option) >= startIndex);
  };
  const getFirstOption = () => {
    return getOptionAtIndex(0);
  };
  const getLastOption = () => {
    return getOptionAtIndex(optionsRef.current.length - 1);
  };
  const getOptionBefore = (option) => {
    const index = getIndexOfOption(option);
    return getOptionAtIndex(index - 1);
  };
  const getOptionAfter = (option) => {
    const index = getIndexOfOption(option);
    return getOptionAtIndex(index + 1);
  };
  const listRef = React.useRef(null);
  const getOptionPageAbove = (start) => {
    const list = listRef.current;
    let option = optionsRef.current.find((option2) => option2.data === start);
    if (!list || !option) {
      return null;
    }
    const containerRect = list.getBoundingClientRect();
    let optionRect = option.element.getBoundingClientRect();
    const listY = containerRect.y - list.scrollTop;
    const pageY = Math.max(
      0,
      optionRect.y - listY + optionRect.height - containerRect.height
    );
    while (option && optionRect.y - listY > pageY) {
      option = getOptionBefore(option.data);
      optionRect = option == null ? void 0 : option.element.getBoundingClientRect();
    }
    return option != null ? option : getFirstOption();
  };
  const getOptionPageBelow = (start) => {
    const list = listRef.current;
    let option = optionsRef.current.find((option2) => option2.data === start);
    if (!list || !option) {
      return null;
    }
    const containerRect = list.getBoundingClientRect();
    let optionRect = option.element.getBoundingClientRect();
    const listY = containerRect.y - list.scrollTop;
    const pageY = Math.min(
      list.scrollHeight,
      optionRect.y - listY - optionRect.height + containerRect.height
    );
    while (option && optionRect.y - listY < pageY) {
      option = getOptionAfter(option.data);
      optionRect = option == null ? void 0 : option.element.getBoundingClientRect();
    }
    return option != null ? option : getLastOption();
  };
  React.useEffect(() => {
    var _a;
    if (listRef.current) {
      const activeElement = (_a = optionsRef.current.find(
        (option) => option.data === activeState
      )) == null ? void 0 : _a.element;
      if (!activeElement) {
        return;
      }
      activeElement.scrollIntoView({
        block: "nearest",
        inline: "nearest"
      });
    }
  }, [activeState]);
  return {
    multiselect: Boolean(multiselect),
    openState,
    setOpen,
    openKey,
    activeState,
    setActive,
    selectedState,
    setSelectedState,
    select,
    clear,
    focusVisibleState,
    setFocusVisibleState,
    focusedState,
    setFocusedState,
    listRef,
    options: optionsRef.current.map((option) => option.element),
    register,
    getOptionAtIndex,
    getIndexOfOption,
    getOptionsMatching,
    getOptionFromSearch,
    getOptionAfter,
    getOptionBefore,
    getOptionPageAbove,
    getOptionPageBelow,
    getFirstOption,
    getLastOption,
    valueToString,
    disabled
  };
}

exports.defaultValueToString = defaultValueToString;
exports.useListControl = useListControl;
//# sourceMappingURL=ListControlState.js.map
