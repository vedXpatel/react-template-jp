import { getLocalTimeZone, startOfMonth, CalendarDate, endOfMonth } from '@internationalized/date';
import { useForkRef, useControlled, useFormFieldProps } from '@salt-ds/core';
import { useMemo, useRef, useState, useEffect, useCallback } from 'react';
import '../calendar/Calendar.js';
import '../calendar/CalendarNavigation.js';
import '../calendar/CalendarWeekHeader.js';
import '../calendar/CalendarDateGrid.js';
import '../calendar/internal/CalendarContext.js';
import { getCurrentLocale } from '../calendar/formatDate.js';
import { CALENDAR_MIN_YEAR, CALENDAR_MAX_YEAR } from '../calendar/useCalendarSelection.js';
import { useDatePickerOverlay } from './DatePickerOverlayProvider.js';

function useDatePicker(props, ref) {
  const {
    readOnly = false,
    disabled,
    selectionVariant,
    defaultSelectedDate = null,
    selectedDate: selectedDateProp,
    onSelectedDateChange,
    onApply,
    minDate: minDateProp,
    maxDate: maxDateProp,
    timeZone = getLocalTimeZone(),
    locale = getCurrentLocale(),
    onCancel
  } = props;
  const minDate = useMemo(
    () => minDateProp != null ? minDateProp : startOfMonth(new CalendarDate(CALENDAR_MIN_YEAR, 1, 1)),
    [minDateProp]
  );
  const maxDate = useMemo(
    () => maxDateProp != null ? maxDateProp : endOfMonth(new CalendarDate(CALENDAR_MAX_YEAR, 1, 1)),
    [maxDateProp]
  );
  const datePickerRef = useRef(null);
  const containerRef = useForkRef(ref, datePickerRef);
  const {
    state: { open },
    helpers: { setOpen }
  } = useDatePickerOverlay();
  const [selectedDate, setSelectedDate] = useControlled({
    controlled: selectedDateProp,
    default: defaultSelectedDate,
    name: "DatePicker",
    state: "selectedDate"
  });
  const [enableApply, setEnableApply] = useState(false);
  const [cancelled, setCancelled] = useState(false);
  useEffect(() => {
    if (open) {
      setCancelled(false);
    }
  }, [open]);
  const { disabled: formFieldDisabled, readOnly: formFieldReadOnly } = useFormFieldProps();
  const isReadOnly = readOnly || formFieldReadOnly || false;
  const isDisabled = disabled || formFieldDisabled || false;
  const applySingle = (appliedDate, error) => {
    setCancelled(false);
    setOpen(false);
    if (selectionVariant === "single") {
      onApply == null ? void 0 : onApply(appliedDate, error);
    }
  };
  const setSelectedSingleDate = useCallback(
    (selection, error) => {
      let nextDate;
      if (error || !selection) {
        nextDate = selection;
      } else {
        let dateAfterMinDate = true;
        let dateBeforeMaxDate = true;
        if (minDate && selection) {
          dateAfterMinDate = selection.compare(minDate) >= 0;
        }
        if (maxDate && selection) {
          dateBeforeMaxDate = selection.compare(maxDate) <= 0;
        }
        nextDate = dateAfterMinDate && dateBeforeMaxDate ? selection : null;
      }
      setSelectedDate(nextDate);
      if (selectionVariant === "single") {
        onSelectedDateChange == null ? void 0 : onSelectedDateChange(nextDate, error);
      }
      if (!enableApply) {
        setOpen(false);
      }
    },
    [
      enableApply,
      minDate,
      maxDate,
      onSelectedDateChange,
      selectionVariant,
      setSelectedDate,
      setOpen
    ]
  );
  const applyRange = (appliedDate, error) => {
    setCancelled(false);
    if ((appliedDate == null ? void 0 : appliedDate.startDate) && (appliedDate == null ? void 0 : appliedDate.endDate)) {
      setOpen(false);
    }
    if (selectionVariant === "range") {
      onApply == null ? void 0 : onApply(appliedDate, error);
    }
  };
  const setSelectedRangeDate = useCallback(
    (selection, error) => {
      let nextDate;
      let nextError = { ...error };
      let startDateInRange = true;
      let endDateInRange = true;
      if ((error == null ? void 0 : error.startDate) || (error == null ? void 0 : error.endDate) || !selection) {
        nextDate = selection;
      } else {
        if (maxDate && (selection == null ? void 0 : selection.startDate)) {
          startDateInRange = selection.startDate.compare(minDate) >= 0;
        }
        if (maxDate && (selection == null ? void 0 : selection.endDate)) {
          endDateInRange = (selection == null ? void 0 : selection.endDate) && selection.endDate.compare(maxDate) <= 0;
        }
        if (!startDateInRange && !endDateInRange) {
          nextDate = null;
          nextError = {
            startDate: "is before min date",
            endDate: "is after max date"
          };
        } else {
          nextDate = {
            startDate: selection.startDate || null,
            endDate: selection.endDate || null
          };
          nextError = {
            startDate: !startDateInRange ? "is before min date" : nextError.startDate,
            endDate: !endDateInRange ? "is after max date" : nextError.endDate
          };
        }
      }
      setSelectedDate(nextDate);
      if (selectionVariant === "range") {
        onSelectedDateChange == null ? void 0 : onSelectedDateChange(nextDate, nextError);
      }
      if (!enableApply && (nextDate == null ? void 0 : nextDate.startDate) && (nextDate == null ? void 0 : nextDate.endDate)) {
        setOpen(false);
      }
    },
    [
      enableApply,
      minDate,
      maxDate,
      onSelectedDateChange,
      selectionVariant,
      setSelectedDate,
      setOpen
    ]
  );
  const cancel = () => {
    setCancelled(true);
    setOpen(false);
    onCancel == null ? void 0 : onCancel();
  };
  const returnValue = {
    state: {
      selectionVariant,
      selectedDate,
      cancelled,
      enableApply,
      disabled: isDisabled,
      readOnly: isReadOnly,
      containerRef,
      minDate,
      maxDate,
      locale,
      timeZone
    },
    helpers: {
      cancel,
      setEnableApply
    }
  };
  if (props.selectionVariant === "range") {
    return {
      ...returnValue,
      helpers: {
        ...returnValue.helpers,
        apply: applyRange,
        setSelectedDate: setSelectedRangeDate
      }
    };
  }
  return {
    ...returnValue,
    helpers: {
      ...returnValue.helpers,
      apply: applySingle,
      setSelectedDate: setSelectedSingleDate
    }
  };
}

export { useDatePicker };
//# sourceMappingURL=useDatePicker.js.map
