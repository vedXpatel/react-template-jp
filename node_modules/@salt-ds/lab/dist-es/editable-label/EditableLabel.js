import { jsx } from 'react/jsx-runtime';
import { useControlled, useIsomorphicLayoutEffect } from '@salt-ds/core';
import { clsx } from 'clsx';
import { forwardRef, useRef, useCallback } from 'react';
import { InputLegacy } from '../input-legacy/InputLegacy.js';
import '../input-legacy/StaticInputAdornment.js';
import { useComponentCssInjection } from '@salt-ds/styles';
import { useWindow } from '@salt-ds/window';
import css_248z from './EditableLabel.css.js';

const classBase = "saltEditableLabel";
const EditableLabel = forwardRef(function EditableLabel2({
  className: classNameProp,
  defaultEditing,
  defaultValue,
  editing: editingProp,
  onChange,
  onEnterEditMode,
  onExitEditMode,
  value: valueProp
}, forwardedRef) {
  const targetWindow = useWindow();
  useComponentCssInjection({
    testId: "salt-editable-label",
    css: css_248z,
    window: targetWindow
  });
  const inputRef = useRef(null);
  const [value, setValue] = useControlled({
    controlled: valueProp,
    default: defaultValue != null ? defaultValue : "",
    name: "EditableLabel",
    state: "value"
  });
  const [editing, setEditing] = useControlled({
    controlled: editingProp,
    default: defaultEditing || false,
    name: "EditableLabel",
    state: "editing"
  });
  const initialValue = useRef(value);
  useIsomorphicLayoutEffect(() => {
    if (editing) {
      if (inputRef.current !== null) {
        inputRef.current.select();
        inputRef.current.focus();
      }
    }
  }, [editing]);
  const enterEditMode = useCallback(() => {
    setEditing(true);
    onEnterEditMode == null ? void 0 : onEnterEditMode();
  }, [onEnterEditMode]);
  const exitEditMode = ({
    cancelEdit = false,
    allowDeactivation = false
  } = {}) => {
    setEditing(false);
    const originalValue = initialValue.current;
    if (originalValue !== value) {
      if (cancelEdit) {
        setValue(originalValue);
      } else {
        initialValue.current = value;
      }
    }
    onExitEditMode == null ? void 0 : onExitEditMode(originalValue, value, allowDeactivation);
  };
  const handleChange = (evt) => {
    const { value: value2 } = evt.target;
    setValue(value2);
    onChange == null ? void 0 : onChange(value2);
  };
  const handleDoubleClick = () => {
    enterEditMode();
  };
  const handleBlur = () => {
    exitEditMode({ allowDeactivation: true });
  };
  const handleKeyDown = (evt) => {
    if (editing && evt.key === "Enter") {
      evt.stopPropagation();
      exitEditMode();
    } else if (evt.key === "ArrowRight" || evt.key === "ArrowLeft") {
      evt.stopPropagation();
    } else if (evt.key === "Escape") {
      exitEditMode({ cancelEdit: true });
    }
  };
  const className = clsx(classBase, classNameProp, {
    [`${classBase}-editing`]: editing
  });
  return /* @__PURE__ */ jsx("div", {
    className,
    onDoubleClick: handleDoubleClick,
    "data-text": value,
    ref: forwardedRef,
    children: editing ? /* @__PURE__ */ jsx(InputLegacy, {
      inputProps: { className: `${classBase}-input` },
      value,
      onBlur: handleBlur,
      onChange: handleChange,
      onKeyDown: handleKeyDown,
      ref: inputRef,
      style: { padding: 0 },
      textAlign: "left"
    }) : value
  });
});

export { EditableLabel };
//# sourceMappingURL=EditableLabel.js.map
