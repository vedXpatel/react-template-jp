import { getLocalTimeZone, today, startOfMonth, endOfMonth, endOfYear, startOfYear, isSameMonth, isSameDay } from '@internationalized/date';
import { useControlled } from '@salt-ds/core';
import { useCallback, useState, useEffect, useMemo } from 'react';
import { getCurrentLocale } from './formatDate.js';
import { generateDatesForMonth } from './internal/utils.js';
import { useCalendarSelection, isDateRangeSelection } from './useCalendarSelection.js';

const defaultIsDayUnselectable = () => false;
const defaultIsDayHighlighted = () => false;
const defaultIsDayDisabled = () => false;
function useCalendar(props) {
  const {
    selectedDate,
    defaultSelectedDate,
    visibleMonth: visibleMonthProp,
    hideOutOfRangeDates,
    timeZone = getLocalTimeZone(),
    locale = getCurrentLocale(),
    defaultVisibleMonth = today(timeZone),
    onSelectedDateChange,
    onVisibleMonthChange,
    isDayUnselectable = defaultIsDayUnselectable,
    isDayHighlighted = defaultIsDayHighlighted,
    isDayDisabled = defaultIsDayDisabled,
    minDate,
    maxDate,
    selectionVariant,
    onHoveredDateChange,
    hoveredDate
  } = props;
  const [visibleMonth, setVisibleMonthState] = useControlled({
    controlled: visibleMonthProp ? startOfMonth(visibleMonthProp) : void 0,
    default: startOfMonth(defaultVisibleMonth),
    name: "Calendar",
    state: "visibleMonth"
  });
  const isOutsideAllowedDates = useCallback(
    (date) => {
      return minDate && date.compare(minDate) < 0 || maxDate && date.compare(maxDate) > 0;
    },
    [maxDate, minDate]
  );
  const isOutsideAllowedMonths = useCallback(
    (date) => {
      return minDate && endOfMonth(date).compare(minDate) < 0 || maxDate && startOfMonth(date).compare(maxDate) > 0;
    },
    [minDate, maxDate]
  );
  const isOutsideAllowedYears = useCallback(
    (date) => {
      return minDate && endOfYear(date).compare(minDate) < 0 || maxDate && startOfYear(date).compare(maxDate) > 0;
    },
    [minDate, maxDate]
  );
  const isDaySelectable = useCallback(
    (date) => !(date && (isDayUnselectable(date) || isDayDisabled(date) || isOutsideAllowedDates(date))),
    [isDayUnselectable, isDayDisabled, isOutsideAllowedDates]
  );
  const selectionManager = useCalendarSelection({
    defaultSelectedDate,
    selectedDate,
    onSelectedDateChange,
    startDateOffset: props.selectionVariant === "offset" ? props.startDateOffset : void 0,
    endDateOffset: props.selectionVariant === "offset" ? props.endDateOffset : void 0,
    isDaySelectable,
    selectionVariant,
    onHoveredDateChange,
    hoveredDate
  });
  const [calendarFocused, setCalendarFocused] = useState(false);
  const isInVisibleMonth = useCallback(
    (date) => date != null && isSameMonth(date, visibleMonth),
    [visibleMonth]
  );
  const getInitialFocusedDate = useCallback(() => {
    const selectedDate2 = selectionManager.state.selectedDate;
    if ((selectionVariant === "range" || selectionVariant === "offset") && isDateRangeSelection(selectedDate2)) {
      if (isInVisibleMonth(selectedDate2 == null ? void 0 : selectedDate2.startDate)) {
        return selectedDate2.startDate;
      }
      if (isInVisibleMonth(selectedDate2 == null ? void 0 : selectedDate2.endDate)) {
        return selectedDate2.endDate;
      }
    } else if (selectionVariant === "multiselect" && Array.isArray(selectedDate2)) {
      const selectionInMonth = selectedDate2.filter((day) => isInVisibleMonth(day)).sort((a, b) => a.compare(b));
      if (selectionInMonth.length > 0) {
        return selectionInMonth[0];
      }
    } else if (selectionVariant === "single" && !isDateRangeSelection(selectedDate2) && !Array.isArray(selectedDate2) && isInVisibleMonth(selectedDate2)) {
      return selectedDate2;
    }
    if (isDaySelectable(today(timeZone)) && isInVisibleMonth(today(timeZone))) {
      return today(timeZone);
    }
    const firstSelectableDate = generateDatesForMonth(visibleMonth).find(
      (visibleDay) => isDaySelectable(visibleDay)
    );
    if (firstSelectableDate) {
      return firstSelectableDate;
    }
    return null;
  }, [
    isInVisibleMonth,
    selectionVariant,
    selectionManager.state.selectedDate,
    timeZone,
    visibleMonth
  ]);
  const [focusedDate, setFocusedDateState] = useState(
    getInitialFocusedDate
  );
  const isDayVisible = useCallback(
    (date) => {
      const startInsideDays = startOfMonth(visibleMonth);
      if (date.compare(startInsideDays) < 0)
        return false;
      const endInsideDays = endOfMonth(visibleMonth);
      return !(date.compare(endInsideDays) > 0);
    },
    [visibleMonth]
  );
  const setVisibleMonth = useCallback(
    (event, newVisibleMonth) => {
      setVisibleMonthState(newVisibleMonth);
      onVisibleMonthChange == null ? void 0 : onVisibleMonthChange(event, newVisibleMonth);
    },
    [onVisibleMonthChange]
  );
  const setFocusedDate = useCallback(
    (event, date) => {
      if (!focusedDate || isSameDay(date, focusedDate) || isOutsideAllowedDates(date))
        return;
      setFocusedDateState(date);
      const shouldTransition = !isDayVisible(date) && isDaySelectable(date) && !isOutsideAllowedDates(date);
      if (shouldTransition) {
        setVisibleMonth(event, startOfMonth(date));
      }
    },
    [
      focusedDate,
      isDaySelectable,
      isDayVisible,
      isOutsideAllowedDates,
      setVisibleMonth
    ]
  );
  useEffect(() => {
    if (visibleMonth && focusedDate && !isDayVisible(focusedDate)) {
      const focusableDate = getInitialFocusedDate();
      if (focusableDate) {
        setFocusedDateState(focusableDate);
      }
    }
  }, [isDayVisible, focusedDate, getInitialFocusedDate, visibleMonth]);
  return useMemo(
    () => ({
      state: {
        visibleMonth,
        focusedDate,
        minDate,
        maxDate,
        selectionVariant,
        hideOutOfRangeDates,
        calendarFocused,
        timeZone,
        locale,
        ...selectionManager.state
      },
      helpers: {
        setVisibleMonth,
        setFocusedDate,
        setCalendarFocused,
        isDayUnselectable,
        isDayHighlighted,
        isDayDisabled,
        isDayVisible,
        isOutsideAllowedDates,
        isOutsideAllowedMonths,
        isOutsideAllowedYears,
        ...selectionManager.helpers
      }
    }),
    [
      visibleMonth,
      focusedDate,
      minDate,
      maxDate,
      selectionVariant,
      hideOutOfRangeDates,
      calendarFocused,
      timeZone,
      locale,
      setVisibleMonth,
      setFocusedDate,
      isDayUnselectable,
      isDayHighlighted,
      isDayDisabled,
      isDayVisible,
      isOutsideAllowedDates,
      isOutsideAllowedMonths,
      isOutsideAllowedYears,
      selectionManager
    ]
  );
}

export { useCalendar };
//# sourceMappingURL=useCalendar.js.map
