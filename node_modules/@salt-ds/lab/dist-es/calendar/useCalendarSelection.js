import { CalendarDate, CalendarDateTime, ZonedDateTime, isSameDay } from '@internationalized/date';
import { makePrefixer, useControlled } from '@salt-ds/core';
import { clsx } from 'clsx';
import { useCallback, useMemo } from 'react';
import { useCalendarContext } from './internal/CalendarContext.js';

const CALENDAR_MIN_YEAR = 1900;
const CALENDAR_MAX_YEAR = 2100;
function isSingleSelectionValueType(value) {
  return value instanceof CalendarDate || value instanceof CalendarDateTime || value instanceof ZonedDateTime;
}
function isDateRangeSelection(value) {
  return value && typeof value === "object" && ("startDate" in value || "endDate" in value);
}
function isMultipleDateSelection(value) {
  return Array.isArray(value) && value.every((item) => isSingleSelectionValueType(item));
}
const withBaseName = makePrefixer("saltCalendarDay");
function addOrRemoveFromArray(array, item) {
  if (Array.isArray(array)) {
    if (array.find((element) => isSameDay(element, item))) {
      return array.filter((element) => !isSameDay(element, item));
    }
    return array.concat(item);
  }
  return [item];
}
const updateRangeSelection = (currentSelectedDate, newSelectedDate) => {
  let base = { ...currentSelectedDate };
  if ((base == null ? void 0 : base.startDate) && (base == null ? void 0 : base.endDate)) {
    base = { startDate: newSelectedDate };
  } else if ((base == null ? void 0 : base.startDate) && newSelectedDate.compare(base.startDate) < 0) {
    base = { startDate: newSelectedDate };
  } else if ((base == null ? void 0 : base.startDate) && newSelectedDate.compare(base.startDate) >= 0) {
    base = { ...base, endDate: newSelectedDate };
  } else {
    base = { startDate: newSelectedDate };
  }
  return base;
};
function useCalendarSelection(props) {
  const {
    hoveredDate: hoveredDateProp,
    selectedDate: selectedDateProp,
    defaultSelectedDate,
    onSelectedDateChange,
    onHoveredDateChange,
    isDaySelectable,
    selectionVariant
  } = props;
  const [selectedDate, setSelectedDateState] = useControlled({
    controlled: selectedDateProp,
    default: defaultSelectedDate,
    name: "Calendar",
    state: "selectedDate"
  });
  const startDateOffset = selectionVariant === "offset" ? props.startDateOffset : void 0;
  const endDateOffset = selectionVariant === "offset" ? props.endDateOffset : void 0;
  const getStartDateOffset = useCallback(
    (date) => {
      if (selectionVariant === "offset" && startDateOffset) {
        return startDateOffset(date);
      }
      return date;
    },
    [selectionVariant, startDateOffset]
  );
  const getEndDateOffset = useCallback(
    (date) => {
      if (selectionVariant === "offset" && endDateOffset) {
        return endDateOffset(date);
      }
      return date;
    },
    [selectionVariant, endDateOffset]
  );
  const setSelectedDate = useCallback(
    (event, newSelectedDate) => {
      var _a;
      if (!isDaySelectable || isDaySelectable(newSelectedDate)) {
        switch (selectionVariant) {
          case "single": {
            setSelectedDateState(newSelectedDate);
            onSelectedDateChange == null ? void 0 : onSelectedDateChange(event, newSelectedDate);
            break;
          }
          case "multiselect": {
            const newMultiSelectDate = addOrRemoveFromArray(
              selectedDate,
              newSelectedDate
            );
            setSelectedDateState(newMultiSelectDate);
            onSelectedDateChange == null ? void 0 : onSelectedDateChange(event, newMultiSelectDate);
            break;
          }
          case "range": {
            const newRangeDate = updateRangeSelection(
              selectedDate,
              newSelectedDate
            );
            setSelectedDateState(newRangeDate);
            onSelectedDateChange == null ? void 0 : onSelectedDateChange(event, newRangeDate);
            break;
          }
          case "offset": {
            const newOffsetDate = {
              startDate: getStartDateOffset(newSelectedDate),
              endDate: getEndDateOffset(newSelectedDate)
            };
            setSelectedDateState(newOffsetDate);
            (_a = props.onSelectedDateChange) == null ? void 0 : _a.call(props, event, newOffsetDate);
            break;
          }
        }
      }
    },
    [isDaySelectable, selectedDate, selectionVariant, onSelectedDateChange]
  );
  const isSelected = useCallback(
    (date) => {
      switch (selectionVariant) {
        case "single":
          return isSingleSelectionValueType(selectedDate) && isSameDay(selectedDate, date);
        case "multiselect":
          return Array.isArray(selectedDate) && !!selectedDate.find((element) => isSameDay(element, date));
        default:
          return false;
      }
    },
    [selectionVariant, selectedDate]
  );
  const [hoveredDate, setHoveredDateState] = useControlled({
    controlled: hoveredDateProp,
    default: void 0,
    name: "Calendar",
    state: "hoveredDate"
  });
  const setHoveredDate = useCallback(
    (event, date) => {
      setHoveredDateState(date);
      onHoveredDateChange == null ? void 0 : onHoveredDateChange(event, date);
    },
    [onHoveredDateChange]
  );
  const isHovered = useCallback(
    (date) => {
      return !!hoveredDate && isSameDay(date, hoveredDate);
    },
    [hoveredDate]
  );
  const isSelectedSpan = useCallback(
    (date) => {
      if ((selectionVariant === "range" || selectionVariant === "offset") && isDateRangeSelection(selectedDate) && (selectedDate == null ? void 0 : selectedDate.startDate) && (selectedDate == null ? void 0 : selectedDate.endDate)) {
        return date.compare(selectedDate.startDate) > 0 && date.compare(selectedDate.endDate) < 0;
      }
      return false;
    },
    [selectionVariant, selectedDate]
  );
  const isHoveredSpan = useCallback(
    (date) => {
      if ((selectionVariant === "range" || selectionVariant === "offset") && isDateRangeSelection(selectedDate) && selectedDate.startDate && !selectedDate.endDate && hoveredDate) {
        const isForwardRange = hoveredDate.compare(selectedDate.startDate) > 0 && (date.compare(selectedDate.startDate) > 0 && date.compare(hoveredDate) < 0 || isSameDay(date, hoveredDate));
        const isValidDayHovered = !isDaySelectable || isDaySelectable(hoveredDate);
        return isForwardRange && isValidDayHovered;
      }
      return false;
    },
    [selectionVariant, selectedDate, hoveredDate, isDaySelectable]
  );
  const isSelectedStart = useCallback(
    (date) => {
      if ((selectionVariant === "range" || selectionVariant === "offset") && isDateRangeSelection(selectedDate) && selectedDate.startDate) {
        return isSameDay(selectedDate.startDate, date);
      }
      return false;
    },
    [selectionVariant, selectedDate]
  );
  const isSelectedEnd = useCallback(
    (date) => {
      if ((selectionVariant === "range" || selectionVariant === "offset") && isDateRangeSelection(selectedDate) && selectedDate.endDate) {
        return isSameDay(selectedDate.endDate, date);
      }
      return false;
    },
    [selectionVariant, selectedDate]
  );
  const isHoveredOffset = useCallback(
    (date) => {
      if (hoveredDate && selectionVariant === "offset") {
        const startDate = getStartDateOffset(hoveredDate);
        const endDate = getEndDateOffset(hoveredDate);
        return date.compare(startDate) >= 0 && date.compare(endDate) <= 0 && (!isDaySelectable || isDaySelectable(date));
      }
      return false;
    },
    [
      getStartDateOffset,
      getEndDateOffset,
      hoveredDate,
      isDaySelectable,
      selectionVariant
    ]
  );
  return useMemo(
    () => ({
      state: {
        selectedDate,
        hoveredDate
      },
      helpers: {
        setSelectedDate,
        isSelected,
        setHoveredDate,
        isHovered,
        isSelectedSpan,
        isHoveredSpan,
        isSelectedStart,
        isSelectedEnd,
        isHoveredOffset,
        isDaySelectable
      }
    }),
    [
      selectedDate,
      hoveredDate,
      setSelectedDate,
      isSelected,
      setHoveredDate,
      isHovered,
      isSelectedSpan,
      isHoveredSpan,
      isSelectedStart,
      isSelectedEnd,
      isHoveredOffset,
      isDaySelectable
    ]
  );
}
function useCalendarSelectionDay({ date }) {
  const {
    helpers: {
      setSelectedDate,
      isSelected,
      setHoveredDate,
      isSelectedSpan,
      isHoveredSpan,
      isSelectedStart,
      isSelectedEnd,
      isHovered,
      isHoveredOffset,
      isDaySelectable
    }
  } = useCalendarContext();
  const handleClick = useCallback(
    (event) => {
      setSelectedDate(event, date);
    },
    [date, setSelectedDate]
  );
  const handleKeyDown = useCallback(
    (event) => {
      switch (event.key) {
        case "Space":
        case "Enter":
          setSelectedDate(event, date);
          event.preventDefault();
      }
    },
    [date, setSelectedDate]
  );
  const handleMouseOver = useCallback(
    (event) => {
      setHoveredDate(event, date);
    },
    [date, setHoveredDate]
  );
  const handleMouseLeave = useCallback(
    (event) => {
      setHoveredDate(event, null);
    },
    [setHoveredDate]
  );
  const selected = isSelected(date);
  const selectedSpan = isSelectedSpan(date);
  const hoveredSpan = isHoveredSpan(date);
  const selectedStart = isSelectedStart(date);
  const selectedEnd = isSelectedEnd(date);
  const hovered = isHovered(date);
  const hoveredOffset = isHoveredOffset(date);
  return {
    handleClick,
    handleKeyDown,
    handleMouseOver,
    handleMouseLeave,
    status: {
      selected,
      selectedSpan,
      hoveredSpan,
      selectedStart,
      selectedEnd,
      hovered,
      hoveredOffset
    },
    dayProps: {
      className: clsx({
        [withBaseName("selected")]: selected,
        [withBaseName("selectedSpan")]: selectedSpan,
        [withBaseName("hoveredSpan")]: hoveredSpan,
        [withBaseName("selectedStart")]: selectedStart,
        [withBaseName("selectedEnd")]: selectedEnd,
        [withBaseName("hovered")]: hovered,
        [withBaseName("hoveredOffset")]: hoveredOffset
      }),
      "aria-pressed": selected || selectedEnd || selectedStart || selectedSpan ? "true" : void 0,
      "aria-disabled": isDaySelectable && !isDaySelectable(date) ? "true" : void 0
    }
  };
}

export { CALENDAR_MAX_YEAR, CALENDAR_MIN_YEAR, isDateRangeSelection, isMultipleDateSelection, isSingleSelectionValueType, useCalendarSelection, useCalendarSelectionDay };
//# sourceMappingURL=useCalendarSelection.js.map
