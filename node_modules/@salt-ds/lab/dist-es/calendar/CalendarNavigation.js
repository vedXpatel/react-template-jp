import { jsxs, jsx, Fragment } from 'react/jsx-runtime';
import { makePrefixer, useIcon, Button, Dropdown, Tooltip, useListControlContext, Option } from '@salt-ds/core';
import { clsx } from 'clsx';
import { forwardRef, useCallback, useMemo } from 'react';
import { useCalendarContext } from './internal/CalendarContext.js';
import { CALENDAR_MAX_YEAR, CALENDAR_MIN_YEAR } from './useCalendarSelection.js';
import { isSameMonth, isSameYear, CalendarDate } from '@internationalized/date';
import { useComponentCssInjection } from '@salt-ds/styles';
import { useWindow } from '@salt-ds/window';
import css_248z from './CalendarNavigation.css.js';
import { formatDate } from './formatDate.js';
import { monthsForLocale, monthDiff } from './internal/utils.js';

const withBaseName = makePrefixer("saltCalendarNavigation");
const ConditionalTooltip = ({
  children,
  disabled = true,
  ...rest
}) => {
  if (disabled) {
    return /* @__PURE__ */ jsx(Fragment, {
      children
    });
  }
  return /* @__PURE__ */ jsx(Tooltip, {
    ...rest,
    children
  });
};
function generateYearsBetweenRange(minYear, maxYear) {
  const years = [];
  for (let year = minYear; year <= maxYear; year++) {
    years.push(new CalendarDate(year, 1, 1));
  }
  return years;
}
function useCalendarNavigation() {
  const {
    state: { visibleMonth, minDate, maxDate, locale, timeZone },
    helpers: {
      setVisibleMonth,
      isDayVisible,
      isOutsideAllowedYears,
      isOutsideAllowedMonths
    }
  } = useCalendarContext();
  const moveToNextMonth = useCallback(
    (event, step = 1) => {
      setVisibleMonth(event, visibleMonth.add({ months: step }));
    },
    [setVisibleMonth, visibleMonth]
  );
  const moveToPreviousMonth = useCallback(
    (event, step = 1) => {
      setVisibleMonth(event, visibleMonth.subtract({ months: step }));
    },
    [setVisibleMonth, visibleMonth]
  );
  const moveToMonth = useCallback(
    (event, month) => {
      let newMonth = month;
      if (!isOutsideAllowedYears(newMonth)) {
        if (isOutsideAllowedMonths(newMonth)) {
          const navigableMonths = monthsForLocale(visibleMonth, locale).filter(
            (n) => !isOutsideAllowedMonths(n)
          );
          newMonth = navigableMonths.reduce(
            (closestMonth, currentMonth) => Math.abs(monthDiff(currentMonth, newMonth)) < Math.abs(monthDiff(closestMonth, newMonth)) ? currentMonth : closestMonth
          );
        }
        setVisibleMonth(event, newMonth);
      }
    },
    [
      isOutsideAllowedYears,
      isOutsideAllowedMonths,
      setVisibleMonth,
      visibleMonth,
      locale
    ]
  );
  const months = useMemo(
    () => monthsForLocale(visibleMonth, locale),
    [visibleMonth, locale]
  );
  const years = useMemo(
    () => generateYearsBetweenRange(
      Math.min(minDate ? minDate.year : CALENDAR_MIN_YEAR, visibleMonth.year),
      Math.max(maxDate ? maxDate.year : CALENDAR_MAX_YEAR, visibleMonth.year)
    ),
    [minDate, maxDate, visibleMonth.year]
  );
  const selectedMonth = months.find(
    (month) => isSameMonth(month, visibleMonth)
  );
  const selectedYear = years.find(
    (year) => isSameYear(year, visibleMonth)
  );
  const canNavigatePrevious = !(minDate && isDayVisible(minDate));
  const canNavigateNext = !(maxDate && isDayVisible(maxDate));
  return useMemo(
    () => ({
      moveToNextMonth,
      moveToPreviousMonth,
      moveToMonth,
      visibleMonth,
      months,
      years,
      canNavigateNext,
      canNavigatePrevious,
      selectedMonth,
      selectedYear,
      isOutsideAllowedMonths,
      locale,
      timeZone
    }),
    [
      months,
      moveToPreviousMonth,
      moveToNextMonth,
      moveToMonth,
      visibleMonth,
      years,
      canNavigateNext,
      canNavigatePrevious,
      selectedMonth,
      selectedYear,
      isOutsideAllowedMonths,
      locale,
      timeZone
    ]
  );
}
const OptionWithTooltip = ({
  value,
  children,
  disabled = false,
  tooltipContent
}) => {
  const { activeState, openState } = useListControlContext();
  const open = (activeState == null ? void 0 : activeState.value) === value;
  return /* @__PURE__ */ jsx(ConditionalTooltip, {
    placement: "right",
    open: open && openState,
    disabled: !disabled,
    content: tooltipContent,
    enterDelay: 0,
    leaveDelay: 0,
    children: /* @__PURE__ */ jsx(Option, {
      value,
      disabled,
      children
    })
  });
};
const CalendarNavigation = forwardRef(function CalendarNavigation2(props, ref) {
  const {
    className,
    formatMonth: formatMonthProp,
    formatYear: formatYearProp,
    MonthDropdownProps,
    YearDropdownProps,
    hideYearDropdown,
    step = 1,
    ...rest
  } = props;
  const targetWindow = useWindow();
  useComponentCssInjection({
    testId: "salt-calendar-navigation",
    css: css_248z,
    window: targetWindow
  });
  const { NextIcon, PreviousIcon } = useIcon();
  const {
    moveToPreviousMonth,
    moveToNextMonth,
    moveToMonth,
    months,
    years,
    canNavigateNext,
    canNavigatePrevious,
    selectedMonth,
    selectedYear,
    isOutsideAllowedMonths,
    locale
  } = useCalendarNavigation();
  const handleNavigatePrevious = useCallback(
    (event) => {
      moveToPreviousMonth(event, step);
    },
    [moveToPreviousMonth, step]
  );
  const handleNavigateNext = useCallback(
    (event) => {
      moveToNextMonth(event, step);
    },
    [moveToNextMonth, step]
  );
  const handleMonthSelect = useCallback(
    (event, month) => {
      moveToMonth(event, month[0]);
    },
    [moveToMonth]
  );
  const handleYearSelect = useCallback(
    (event, year) => {
      moveToMonth(event, year[0]);
    },
    [moveToMonth]
  );
  const formatMonth = useCallback(
    (date) => {
      if (date && formatMonthProp) {
        return formatMonthProp(date);
      }
      return !date ? "" : formatDate(date, locale, {
        month: hideYearDropdown ? "long" : "short",
        day: void 0,
        year: void 0
      });
    },
    [formatMonthProp]
  );
  const formatYear = useCallback(
    (date) => {
      if (date && formatYearProp) {
        return formatYearProp(date);
      }
      return !date ? "" : `${date.year}`;
    },
    [formatYearProp]
  );
  return /* @__PURE__ */ jsxs("div", {
    className: clsx(
      withBaseName(),
      { [withBaseName("hideYearDropdown")]: hideYearDropdown },
      className
    ),
    ref,
    ...rest,
    children: [
      /* @__PURE__ */ jsx(ConditionalTooltip, {
        placement: "top",
        disabled: canNavigatePrevious,
        content: "Past dates are out of range",
        enterDelay: 0,
        leaveDelay: 0,
        children: /* @__PURE__ */ jsx(Button, {
          disabled: !canNavigatePrevious,
          appearance: "transparent",
          sentiment: "neutral",
          onClick: handleNavigatePrevious,
          focusableWhenDisabled: true,
          children: /* @__PURE__ */ jsx(PreviousIcon, {
            "aria-label": "Previous Month"
          })
        })
      }),
      /* @__PURE__ */ jsxs("div", {
        className: clsx({ [withBaseName("dropdowns")]: !hideYearDropdown }),
        children: [
          /* @__PURE__ */ jsx(Dropdown, {
            "aria-label": "Month Dropdown",
            selected: selectedMonth ? [selectedMonth] : [],
            value: formatMonth(selectedMonth),
            onSelectionChange: handleMonthSelect,
            ...MonthDropdownProps,
            children: months.map((month) => /* @__PURE__ */ jsx(OptionWithTooltip, {
              value: month,
              disabled: isOutsideAllowedMonths(month),
              tooltipContent: "This month is out of range",
              children: formatMonth(month)
            }, formatMonth(month)))
          }),
          !hideYearDropdown && /* @__PURE__ */ jsx(Dropdown, {
            "aria-label": "Year Dropdown",
            selected: selectedYear ? [selectedYear] : [],
            value: formatYear(selectedYear),
            onSelectionChange: handleYearSelect,
            ...YearDropdownProps,
            children: years.map((year) => /* @__PURE__ */ jsx(OptionWithTooltip, {
              value: year,
              children: formatYear(year)
            }, formatYear(year)))
          })
        ]
      }),
      /* @__PURE__ */ jsx(ConditionalTooltip, {
        placement: "top",
        disabled: canNavigateNext,
        content: "Future dates are out of range",
        enterDelay: 0,
        leaveDelay: 0,
        children: /* @__PURE__ */ jsx(Button, {
          disabled: !canNavigateNext,
          appearance: "transparent",
          sentiment: "neutral",
          onClick: handleNavigateNext,
          focusableWhenDisabled: true,
          children: /* @__PURE__ */ jsx(NextIcon, {
            "aria-label": "Next Month"
          })
        })
      })
    ]
  });
});

export { CalendarNavigation };
//# sourceMappingURL=CalendarNavigation.js.map
