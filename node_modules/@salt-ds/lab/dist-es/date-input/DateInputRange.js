import { jsxs, jsx } from 'react/jsx-runtime';
import { getLocalTimeZone } from '@internationalized/date';
import { makePrefixer, useForkRef, useId, useControlled, useFormFieldProps, StatusAdornment } from '@salt-ds/core';
import { useComponentCssInjection } from '@salt-ds/styles';
import { useWindow } from '@salt-ds/window';
import { clsx } from 'clsx';
import { forwardRef, useRef, useCallback, useEffect, useState } from 'react';
import '../calendar/Calendar.js';
import '../calendar/CalendarNavigation.js';
import '../calendar/CalendarWeekHeader.js';
import '../calendar/CalendarDateGrid.js';
import '../calendar/internal/CalendarContext.js';
import { getCurrentLocale, formatDate } from '../calendar/formatDate.js';
import '../calendar/useCalendarSelection.js';
import css_248z from './DateInput.css.js';
import { parseCalendarDate, extractTimeFieldsFromDateRange } from './utils.js';

const withBaseName = makePrefixer("saltDateInput");
const DateInputRange = forwardRef(
  function DateInputRange2(props, ref) {
    var _a, _b;
    const {
      bordered = false,
      className,
      disabled,
      "aria-label": ariaLabel,
      date: dateProp,
      defaultDate = {},
      onDateChange,
      value: valueProp,
      defaultValue = { startDate: "", endDate: "" },
      onChange,
      onClick,
      onDateValueChange,
      emptyReadOnlyMarker = "\u2014",
      endAdornment,
      format: formatProp,
      startInputProps = {},
      endInputProps = {},
      startInputRef: startInputRefProp,
      endInputRef: endInputRefProp,
      parse = parseCalendarDate,
      placeholder = "dd mmm yyyy",
      readOnly: readOnlyProp,
      validationStatus: validationStatusProp,
      variant = "primary",
      locale = getCurrentLocale(),
      timeZone = getLocalTimeZone(),
      ...rest
    } = props;
    const wrapperRef = useRef(null);
    const handleWrapperRef = useForkRef(ref, wrapperRef);
    const lastError = useRef({
      startDate: false,
      endDate: false
    });
    const startInputRef = useRef(null);
    const handleStartInputRef = useForkRef(startInputRef, startInputRefProp);
    const endInputRef = useRef(null);
    const handleEndInputRef = useForkRef(endInputRef, endInputRefProp);
    const startInputID = useId();
    const endInputID = useId();
    const targetWindow = useWindow();
    useComponentCssInjection({
      testId: "salt-date-input-range",
      css: css_248z,
      window: targetWindow
    });
    const [date, setDate] = useControlled({
      controlled: dateProp,
      default: defaultDate,
      name: "DateInputRange",
      state: "date"
    });
    const [dateValue, setDateValue] = useControlled({
      controlled: valueProp,
      default: defaultValue,
      name: "DateInputRange",
      state: "dateValue"
    });
    const preservedTime = useRef({});
    preservedTime.current = extractTimeFieldsFromDateRange(date);
    const format = useCallback(
      (date2) => {
        return formatProp ? formatProp(date2) : formatDate(date2, locale, { timeZone });
      },
      [formatProp, locale, timeZone]
    );
    const setDateValueFromDate = (newDate) => {
      var _a2, _b2;
      let newDateValue = { ...dateValue };
      const formattedStartDate = format((_a2 = newDate == null ? void 0 : newDate.startDate) != null ? _a2 : null);
      if (formattedStartDate) {
        newDateValue = { ...newDateValue, startDate: formattedStartDate };
      }
      const formattedEndDate = format((_b2 = newDate == null ? void 0 : newDate.endDate) != null ? _b2 : null);
      if (formattedEndDate) {
        newDateValue = { ...newDateValue, endDate: formattedEndDate };
      }
      if ((newDateValue == null ? void 0 : newDateValue.startDate) !== (dateValue == null ? void 0 : dateValue.startDate) || (newDateValue == null ? void 0 : newDateValue.endDate) !== (dateValue == null ? void 0 : dateValue.endDate)) {
        onDateValueChange == null ? void 0 : onDateValueChange(newDateValue, true);
      }
      setDateValue(newDateValue);
    };
    useEffect(() => {
      setDateValueFromDate(date);
    }, [date, date == null ? void 0 : date.startDate, date == null ? void 0 : date.endDate]);
    const [focused, setFocused] = useState(false);
    const {
      a11yProps: {
        "aria-describedby": formFieldDescribedBy,
        "aria-labelledby": formFieldLabelledBy
      } = {},
      disabled: formFieldDisabled,
      readOnly: formFieldReadOnly,
      necessity: formFieldRequired,
      validationStatus: formFieldValidationStatus
    } = useFormFieldProps();
    const isReadOnly = readOnlyProp || formFieldReadOnly;
    const isDisabled = disabled || formFieldDisabled;
    const validationStatus = formFieldValidationStatus != null ? formFieldValidationStatus : validationStatusProp;
    const {
      "aria-describedby": startInputPropsDescribedBy,
      "aria-labelledby": startInputPropsLabelledBy,
      onBlur: startInputPropsOnBlur,
      onChange: startInputPropsOnChange,
      onKeyDown: startInputPropsOnKeyDown,
      onFocus: startInputPropsOnFocus,
      required: startInputPropsRequired,
      ...restStartInputProps
    } = startInputProps;
    const startInputIsRequired = formFieldRequired ? ["required", "asterisk"].includes(formFieldRequired) : startInputPropsRequired;
    const {
      "aria-describedby": endInputPropsDescribedBy,
      "aria-labelledby": endInputPropsLabelledBy,
      onBlur: endInputPropsOnBlur,
      onChange: endInputPropsOnChange,
      onKeyDown: endInputPropsOnKeyDown,
      onFocus: endInputPropsOnFocus,
      required: endInputPropsRequired,
      ...restEndInputProps
    } = endInputProps;
    const endInputIsRequired = formFieldRequired ? ["required", "asterisk"].includes(formFieldRequired) : endInputPropsRequired;
    const apply = (event) => {
      var _a2;
      const { date: newStartDate, error: startDateError } = parse(
        (_a2 = dateValue.startDate) != null ? _a2 : ""
      );
      const { date: newEndDate, error: endDateError } = parse(
        dateValue.endDate || ""
      );
      const hasDateChanged = (newDate2, oldDate) => {
        if (newDate2 && oldDate) {
          return newDate2.compare(oldDate) !== 0;
        }
        return newDate2 !== oldDate;
      };
      const createNewDateRange = (startDate, endDate) => {
        if (!startDate && !endDate) {
          return null;
        }
        const dateRange = {};
        dateRange.startDate = startDate;
        dateRange.endDate = endDate;
        return dateRange;
      };
      const hasStartDateChanged = hasDateChanged(
        newStartDate,
        (date == null ? void 0 : date.startDate) || null
      );
      const hasEndDateChanged = hasDateChanged(
        newEndDate,
        (date == null ? void 0 : date.endDate) || null
      );
      const hasStartOrEndDateChanged = hasStartDateChanged || hasEndDateChanged;
      const newDate = createNewDateRange(
        newStartDate,
        newEndDate
      );
      if ((newDate == null ? void 0 : newDate.startDate) || (newDate == null ? void 0 : newDate.endDate)) {
        setDateValueFromDate(newDate);
      }
      if (hasStartOrEndDateChanged) {
        setDate(newDate);
        if ((newDate == null ? void 0 : newDate.startDate) && preservedTime.current.startTime) {
          newDate.startDate = newDate.startDate.set(
            preservedTime.current.startTime
          );
        }
        if ((newDate == null ? void 0 : newDate.endDate) && preservedTime.current.endTime) {
          newDate.endDate = newDate.endDate.set(preservedTime.current.endTime);
        }
      }
      const error = {
        startDate: startDateError,
        endDate: endDateError
      };
      if (hasStartOrEndDateChanged || lastError.current.startDate !== error.startDate || lastError.current.endDate !== error.endDate) {
        const error2 = {
          startDate: startDateError,
          endDate: endDateError
        };
        onDateChange == null ? void 0 : onDateChange(event, newDate, error2);
        lastError.current = error2;
      }
    };
    const handleStartInputChange = (event) => {
      const newDateValue = { ...dateValue, startDate: event.target.value };
      setDateValue(newDateValue);
      startInputPropsOnChange == null ? void 0 : startInputPropsOnChange(event);
      onChange == null ? void 0 : onChange(event, newDateValue);
      onDateValueChange == null ? void 0 : onDateValueChange(newDateValue, false);
    };
    const handleEndInputChange = (event) => {
      const newDateValue = { ...dateValue, endDate: event.target.value };
      setDateValue(newDateValue);
      endInputPropsOnChange == null ? void 0 : endInputPropsOnChange(event);
      onChange == null ? void 0 : onChange(event, newDateValue);
      onDateValueChange == null ? void 0 : onDateValueChange(newDateValue, false);
    };
    const handleStartInputFocus = (event) => {
      setFocused(true);
      startInputPropsOnFocus == null ? void 0 : startInputPropsOnFocus(event);
    };
    const handleEndInputFocus = (event) => {
      setFocused(true);
      endInputPropsOnFocus == null ? void 0 : endInputPropsOnFocus(event);
    };
    const handleStartInputBlur = (event) => {
      setFocused(false);
      apply(event);
      startInputPropsOnBlur == null ? void 0 : startInputPropsOnBlur(event);
    };
    const handleEndInputBlur = (event) => {
      setFocused(false);
      apply(event);
      endInputPropsOnBlur == null ? void 0 : endInputPropsOnBlur(event);
    };
    const handleStartInputKeyDown = (event) => {
      if (event.key === "Enter") {
        apply(event);
      }
      startInputPropsOnKeyDown == null ? void 0 : startInputPropsOnKeyDown(event);
    };
    const handleEndInputKeyDown = (event) => {
      if (event.key === "Enter") {
        apply(event);
      }
      endInputPropsOnKeyDown == null ? void 0 : endInputPropsOnKeyDown(event);
    };
    const handleWrapperClick = (event) => {
      if (event.target === wrapperRef.current) {
        const input = startInputRef.current;
        input == null ? void 0 : input.focus();
        input == null ? void 0 : input.setSelectionRange(input.value.length, input.value.length);
      }
      onClick == null ? void 0 : onClick(event);
    };
    return /* @__PURE__ */ jsxs("div", {
      className: clsx(
        withBaseName(),
        withBaseName(variant),
        {
          [withBaseName("focused")]: !isDisabled && focused,
          [withBaseName("disabled")]: isDisabled,
          [withBaseName("readOnly")]: isReadOnly,
          [withBaseName(validationStatus != null ? validationStatus : "")]: validationStatus,
          [withBaseName("bordered")]: bordered
        },
        className
      ),
      ref: handleWrapperRef,
      onClick: handleWrapperClick,
      ...rest,
      children: [
        /* @__PURE__ */ jsx("input", {
          autoComplete: "off",
          "aria-describedby": clsx(
            formFieldDescribedBy,
            startInputPropsDescribedBy
          ),
          "aria-labelledby": clsx(
            formFieldLabelledBy,
            startInputPropsLabelledBy,
            startInputID
          ),
          "aria-label": clsx("Start date", ariaLabel),
          id: startInputID,
          className: withBaseName("input"),
          disabled: isDisabled,
          readOnly: isReadOnly,
          ref: handleStartInputRef,
          tabIndex: isDisabled ? -1 : 0,
          placeholder,
          size: placeholder.length,
          value: isReadOnly && !(dateValue == null ? void 0 : dateValue.startDate) ? emptyReadOnlyMarker : (_a = dateValue.startDate) != null ? _a : "",
          ...restStartInputProps,
          onBlur: handleStartInputBlur,
          onChange: handleStartInputChange,
          onKeyDown: handleStartInputKeyDown,
          onFocus: !isDisabled ? handleStartInputFocus : void 0,
          required: startInputIsRequired
        }),
        /* @__PURE__ */ jsx("span", {
          children: "-"
        }),
        /* @__PURE__ */ jsx("input", {
          autoComplete: "off",
          "aria-describedby": clsx(
            formFieldDescribedBy,
            endInputPropsDescribedBy
          ),
          "aria-labelledby": clsx(
            formFieldLabelledBy,
            endInputPropsLabelledBy,
            endInputID
          ),
          "aria-label": clsx("End date", ariaLabel),
          id: endInputID,
          className: withBaseName("input"),
          disabled: isDisabled,
          readOnly: isReadOnly,
          ref: handleEndInputRef,
          tabIndex: isDisabled ? -1 : 0,
          placeholder,
          size: placeholder.length,
          value: isReadOnly && !(dateValue == null ? void 0 : dateValue.endDate) ? emptyReadOnlyMarker : (_b = dateValue.endDate) != null ? _b : "",
          ...restEndInputProps,
          onBlur: handleEndInputBlur,
          onChange: handleEndInputChange,
          onKeyDown: handleEndInputKeyDown,
          onFocus: !isDisabled ? handleEndInputFocus : void 0,
          required: endInputIsRequired
        }),
        /* @__PURE__ */ jsxs("div", {
          className: withBaseName("endAdornmentContainer"),
          children: [
            !isDisabled && !isReadOnly && validationStatus && /* @__PURE__ */ jsx(StatusAdornment, {
              status: validationStatus
            }),
            endAdornment
          ]
        }),
        /* @__PURE__ */ jsx("div", {
          className: withBaseName("activationIndicator")
        })
      ]
    });
  }
);

export { DateInputRange };
//# sourceMappingURL=DateInputRange.js.map
