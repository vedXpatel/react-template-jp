import { jsxs, jsx } from 'react/jsx-runtime';
import { getLocalTimeZone } from '@internationalized/date';
import { makePrefixer, useForkRef, useId, useControlled, useFormFieldProps, StatusAdornment } from '@salt-ds/core';
import { useComponentCssInjection } from '@salt-ds/styles';
import { useWindow } from '@salt-ds/window';
import { clsx } from 'clsx';
import { forwardRef, useRef, useCallback, useEffect, useState } from 'react';
import '../calendar/Calendar.js';
import '../calendar/CalendarNavigation.js';
import '../calendar/CalendarWeekHeader.js';
import '../calendar/CalendarDateGrid.js';
import '../calendar/internal/CalendarContext.js';
import { getCurrentLocale, formatDate } from '../calendar/formatDate.js';
import '../calendar/useCalendarSelection.js';
import css_248z from './DateInput.css.js';
import { parseCalendarDate, extractTimeFieldsFromDate } from './utils.js';

const withBaseName = makePrefixer("saltDateInput");
const DateInputSingle = forwardRef(
  function DateInput(props, ref) {
    const {
      bordered = false,
      className,
      disabled,
      "aria-label": ariaLabel,
      date: dateProp,
      defaultDate,
      onDateChange,
      value: valueProp,
      defaultValue = "",
      onChange,
      onClick,
      emptyReadOnlyMarker = "\u2014",
      endAdornment,
      format: formatProp,
      inputProps = {},
      inputRef: inputRefProp = null,
      parse = parseCalendarDate,
      placeholder = "dd mmm yyyy",
      readOnly: readOnlyProp,
      validationStatus: validationStatusProp,
      variant = "primary",
      onDateValueChange,
      locale = getCurrentLocale(),
      timeZone = getLocalTimeZone(),
      ...rest
    } = props;
    const wrapperRef = useRef(null);
    const lastError = useRef(false);
    const handleWrapperRef = useForkRef(ref, wrapperRef);
    const innerInputRef = useRef(null);
    const handleInputRef = useForkRef(
      innerInputRef,
      inputRefProp
    );
    const inputId = useId();
    const targetWindow = useWindow();
    useComponentCssInjection({
      testId: "salt-date-input-single",
      css: css_248z,
      window: targetWindow
    });
    const [date, setDate] = useControlled({
      controlled: dateProp,
      default: defaultDate,
      name: "DateInputSingle",
      state: "date"
    });
    const [dateValue, setDateValue] = useControlled({
      controlled: valueProp,
      default: defaultValue,
      name: "DateInputSingle",
      state: "dateValue"
    });
    const preservedTime = useRef(
      extractTimeFieldsFromDate(date || null)
    );
    const format = useCallback(
      (date2) => {
        return formatProp ? formatProp(date2) : formatDate(date2, locale, { timeZone });
      },
      [formatProp, locale, timeZone]
    );
    useEffect(() => {
      const formattedDate = format(date || null);
      if (formattedDate) {
        setDateValue(formattedDate);
        onDateValueChange == null ? void 0 : onDateValueChange(formattedDate, true);
      }
    }, [date, format, locale, timeZone]);
    const [focused, setFocused] = useState(false);
    const {
      a11yProps: {
        "aria-describedby": formFieldDescribedBy,
        "aria-labelledby": formFieldLabelledBy
      } = {},
      disabled: formFieldDisabled,
      readOnly: formFieldReadOnly,
      necessity: formFieldRequired,
      validationStatus: formFieldValidationStatus
    } = useFormFieldProps();
    const isReadOnly = readOnlyProp || formFieldReadOnly;
    const isDisabled = disabled || formFieldDisabled;
    const validationStatus = formFieldValidationStatus != null ? formFieldValidationStatus : validationStatusProp;
    const {
      "aria-describedby": dateInputDescribedBy,
      "aria-labelledby": dateInputLabelledBy,
      onBlur: inputPropsOnBlur,
      onChange: inputPropsOnChange,
      onKeyDown: inputPropsOnKeyDown,
      onFocus: inputPropsOnFocus,
      required: dateInputPropsRequired,
      ...restDateInputProps
    } = inputProps;
    const isRequired = formFieldRequired ? ["required", "asterisk"].includes(formFieldRequired) : dateInputPropsRequired;
    const apply = (event) => {
      const { date: parsedDate, error } = parse(dateValue != null ? dateValue : "");
      let newDate = parsedDate;
      if (newDate) {
        const formattedDate = format(newDate);
        if (formattedDate) {
          setDateValue(formattedDate);
          onDateValueChange == null ? void 0 : onDateValueChange(formattedDate, true);
        }
      }
      const hasDateChanged = newDate && date ? newDate.compare(date) !== 0 : newDate !== date;
      if (hasDateChanged) {
        setDate(newDate);
        if (newDate && preservedTime.current) {
          newDate = newDate.set(preservedTime.current);
        }
      }
      if (hasDateChanged || lastError.current !== error) {
        onDateChange == null ? void 0 : onDateChange(event, newDate, error);
      }
      lastError.current = error;
    };
    const handleChange = (event) => {
      const newDateValue = event.target.value;
      setDateValue(newDateValue);
      inputPropsOnChange == null ? void 0 : inputPropsOnChange(event);
      onChange == null ? void 0 : onChange(event);
      onDateValueChange == null ? void 0 : onDateValueChange(newDateValue, false);
    };
    const handleFocus = (event) => {
      setFocused(true);
      inputPropsOnFocus == null ? void 0 : inputPropsOnFocus(event);
    };
    const handleBlur = (event) => {
      setFocused(false);
      apply(event);
      inputPropsOnBlur == null ? void 0 : inputPropsOnBlur(event);
    };
    const handleKeyDown = (event) => {
      if (event.key === "Enter") {
        apply(event);
      }
      inputPropsOnKeyDown == null ? void 0 : inputPropsOnKeyDown(event);
    };
    const handleClick = (event) => {
      var _a;
      if (event.target === wrapperRef.current) {
        (_a = innerInputRef == null ? void 0 : innerInputRef.current) == null ? void 0 : _a.focus();
      }
      onClick == null ? void 0 : onClick(event);
    };
    return /* @__PURE__ */ jsxs("div", {
      className: clsx(
        withBaseName(),
        withBaseName(variant),
        {
          [withBaseName("focused")]: !isDisabled && focused,
          [withBaseName("disabled")]: isDisabled,
          [withBaseName("readOnly")]: isReadOnly,
          [withBaseName(validationStatus != null ? validationStatus : "")]: validationStatus,
          [withBaseName("bordered")]: bordered
        },
        className
      ),
      ref: handleWrapperRef,
      onClick: handleClick,
      ...rest,
      children: [
        /* @__PURE__ */ jsx("input", {
          autoComplete: "off",
          "aria-describedby": clsx(formFieldDescribedBy, dateInputDescribedBy),
          "aria-labelledby": clsx(
            formFieldLabelledBy,
            dateInputLabelledBy,
            inputId
          ),
          "aria-label": clsx("Selected date", ariaLabel),
          id: inputId,
          className: withBaseName("input"),
          disabled: isDisabled,
          readOnly: isReadOnly,
          ref: handleInputRef,
          tabIndex: isDisabled ? -1 : 0,
          placeholder,
          size: placeholder.length,
          value: isReadOnly && !dateValue ? emptyReadOnlyMarker : dateValue,
          ...restDateInputProps,
          onBlur: handleBlur,
          onChange: handleChange,
          onKeyDown: handleKeyDown,
          onFocus: !isDisabled ? handleFocus : void 0,
          required: isRequired
        }),
        /* @__PURE__ */ jsxs("div", {
          className: withBaseName("endAdornmentContainer"),
          children: [
            !isDisabled && !isReadOnly && validationStatus && /* @__PURE__ */ jsx(StatusAdornment, {
              status: validationStatus
            }),
            endAdornment
          ]
        }),
        /* @__PURE__ */ jsx("div", {
          className: withBaseName("activationIndicator")
        })
      ]
    });
  }
);

export { DateInputSingle };
//# sourceMappingURL=DateInputSingle.js.map
