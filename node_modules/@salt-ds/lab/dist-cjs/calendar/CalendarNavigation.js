'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var core = require('@salt-ds/core');
var clsx = require('clsx');
var react = require('react');
var CalendarContext = require('./internal/CalendarContext.js');
var useCalendarSelection = require('./useCalendarSelection.js');
var date = require('@internationalized/date');
var styles = require('@salt-ds/styles');
var window = require('@salt-ds/window');
var CalendarNavigation$1 = require('./CalendarNavigation.css.js');
var formatDate = require('./formatDate.js');
var utils = require('./internal/utils.js');

const withBaseName = core.makePrefixer("saltCalendarNavigation");
const ConditionalTooltip = ({
  children,
  disabled = true,
  ...rest
}) => {
  if (disabled) {
    return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, {
      children
    });
  }
  return /* @__PURE__ */ jsxRuntime.jsx(core.Tooltip, {
    ...rest,
    children
  });
};
function generateYearsBetweenRange(minYear, maxYear) {
  const years = [];
  for (let year = minYear; year <= maxYear; year++) {
    years.push(new date.CalendarDate(year, 1, 1));
  }
  return years;
}
function useCalendarNavigation() {
  const {
    state: { visibleMonth, minDate, maxDate, locale, timeZone },
    helpers: {
      setVisibleMonth,
      isDayVisible,
      isOutsideAllowedYears,
      isOutsideAllowedMonths
    }
  } = CalendarContext.useCalendarContext();
  const moveToNextMonth = react.useCallback(
    (event, step = 1) => {
      setVisibleMonth(event, visibleMonth.add({ months: step }));
    },
    [setVisibleMonth, visibleMonth]
  );
  const moveToPreviousMonth = react.useCallback(
    (event, step = 1) => {
      setVisibleMonth(event, visibleMonth.subtract({ months: step }));
    },
    [setVisibleMonth, visibleMonth]
  );
  const moveToMonth = react.useCallback(
    (event, month) => {
      let newMonth = month;
      if (!isOutsideAllowedYears(newMonth)) {
        if (isOutsideAllowedMonths(newMonth)) {
          const navigableMonths = utils.monthsForLocale(visibleMonth, locale).filter(
            (n) => !isOutsideAllowedMonths(n)
          );
          newMonth = navigableMonths.reduce(
            (closestMonth, currentMonth) => Math.abs(utils.monthDiff(currentMonth, newMonth)) < Math.abs(utils.monthDiff(closestMonth, newMonth)) ? currentMonth : closestMonth
          );
        }
        setVisibleMonth(event, newMonth);
      }
    },
    [
      isOutsideAllowedYears,
      isOutsideAllowedMonths,
      setVisibleMonth,
      visibleMonth,
      locale
    ]
  );
  const months = react.useMemo(
    () => utils.monthsForLocale(visibleMonth, locale),
    [visibleMonth, locale]
  );
  const years = react.useMemo(
    () => generateYearsBetweenRange(
      Math.min(minDate ? minDate.year : useCalendarSelection.CALENDAR_MIN_YEAR, visibleMonth.year),
      Math.max(maxDate ? maxDate.year : useCalendarSelection.CALENDAR_MAX_YEAR, visibleMonth.year)
    ),
    [minDate, maxDate, visibleMonth.year]
  );
  const selectedMonth = months.find(
    (month) => date.isSameMonth(month, visibleMonth)
  );
  const selectedYear = years.find(
    (year) => date.isSameYear(year, visibleMonth)
  );
  const canNavigatePrevious = !(minDate && isDayVisible(minDate));
  const canNavigateNext = !(maxDate && isDayVisible(maxDate));
  return react.useMemo(
    () => ({
      moveToNextMonth,
      moveToPreviousMonth,
      moveToMonth,
      visibleMonth,
      months,
      years,
      canNavigateNext,
      canNavigatePrevious,
      selectedMonth,
      selectedYear,
      isOutsideAllowedMonths,
      locale,
      timeZone
    }),
    [
      months,
      moveToPreviousMonth,
      moveToNextMonth,
      moveToMonth,
      visibleMonth,
      years,
      canNavigateNext,
      canNavigatePrevious,
      selectedMonth,
      selectedYear,
      isOutsideAllowedMonths,
      locale,
      timeZone
    ]
  );
}
const OptionWithTooltip = ({
  value,
  children,
  disabled = false,
  tooltipContent
}) => {
  const { activeState, openState } = core.useListControlContext();
  const open = (activeState == null ? void 0 : activeState.value) === value;
  return /* @__PURE__ */ jsxRuntime.jsx(ConditionalTooltip, {
    placement: "right",
    open: open && openState,
    disabled: !disabled,
    content: tooltipContent,
    enterDelay: 0,
    leaveDelay: 0,
    children: /* @__PURE__ */ jsxRuntime.jsx(core.Option, {
      value,
      disabled,
      children
    })
  });
};
const CalendarNavigation = react.forwardRef(function CalendarNavigation2(props, ref) {
  const {
    className,
    formatMonth: formatMonthProp,
    formatYear: formatYearProp,
    MonthDropdownProps,
    YearDropdownProps,
    hideYearDropdown,
    step = 1,
    ...rest
  } = props;
  const targetWindow = window.useWindow();
  styles.useComponentCssInjection({
    testId: "salt-calendar-navigation",
    css: CalendarNavigation$1,
    window: targetWindow
  });
  const { NextIcon, PreviousIcon } = core.useIcon();
  const {
    moveToPreviousMonth,
    moveToNextMonth,
    moveToMonth,
    months,
    years,
    canNavigateNext,
    canNavigatePrevious,
    selectedMonth,
    selectedYear,
    isOutsideAllowedMonths,
    locale
  } = useCalendarNavigation();
  const handleNavigatePrevious = react.useCallback(
    (event) => {
      moveToPreviousMonth(event, step);
    },
    [moveToPreviousMonth, step]
  );
  const handleNavigateNext = react.useCallback(
    (event) => {
      moveToNextMonth(event, step);
    },
    [moveToNextMonth, step]
  );
  const handleMonthSelect = react.useCallback(
    (event, month) => {
      moveToMonth(event, month[0]);
    },
    [moveToMonth]
  );
  const handleYearSelect = react.useCallback(
    (event, year) => {
      moveToMonth(event, year[0]);
    },
    [moveToMonth]
  );
  const formatMonth = react.useCallback(
    (date) => {
      if (date && formatMonthProp) {
        return formatMonthProp(date);
      }
      return !date ? "" : formatDate.formatDate(date, locale, {
        month: hideYearDropdown ? "long" : "short",
        day: void 0,
        year: void 0
      });
    },
    [formatMonthProp]
  );
  const formatYear = react.useCallback(
    (date) => {
      if (date && formatYearProp) {
        return formatYearProp(date);
      }
      return !date ? "" : `${date.year}`;
    },
    [formatYearProp]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs("div", {
    className: clsx.clsx(
      withBaseName(),
      { [withBaseName("hideYearDropdown")]: hideYearDropdown },
      className
    ),
    ref,
    ...rest,
    children: [
      /* @__PURE__ */ jsxRuntime.jsx(ConditionalTooltip, {
        placement: "top",
        disabled: canNavigatePrevious,
        content: "Past dates are out of range",
        enterDelay: 0,
        leaveDelay: 0,
        children: /* @__PURE__ */ jsxRuntime.jsx(core.Button, {
          disabled: !canNavigatePrevious,
          appearance: "transparent",
          sentiment: "neutral",
          onClick: handleNavigatePrevious,
          focusableWhenDisabled: true,
          children: /* @__PURE__ */ jsxRuntime.jsx(PreviousIcon, {
            "aria-label": "Previous Month"
          })
        })
      }),
      /* @__PURE__ */ jsxRuntime.jsxs("div", {
        className: clsx.clsx({ [withBaseName("dropdowns")]: !hideYearDropdown }),
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(core.Dropdown, {
            "aria-label": "Month Dropdown",
            selected: selectedMonth ? [selectedMonth] : [],
            value: formatMonth(selectedMonth),
            onSelectionChange: handleMonthSelect,
            ...MonthDropdownProps,
            children: months.map((month) => /* @__PURE__ */ jsxRuntime.jsx(OptionWithTooltip, {
              value: month,
              disabled: isOutsideAllowedMonths(month),
              tooltipContent: "This month is out of range",
              children: formatMonth(month)
            }, formatMonth(month)))
          }),
          !hideYearDropdown && /* @__PURE__ */ jsxRuntime.jsx(core.Dropdown, {
            "aria-label": "Year Dropdown",
            selected: selectedYear ? [selectedYear] : [],
            value: formatYear(selectedYear),
            onSelectionChange: handleYearSelect,
            ...YearDropdownProps,
            children: years.map((year) => /* @__PURE__ */ jsxRuntime.jsx(OptionWithTooltip, {
              value: year,
              children: formatYear(year)
            }, formatYear(year)))
          })
        ]
      }),
      /* @__PURE__ */ jsxRuntime.jsx(ConditionalTooltip, {
        placement: "top",
        disabled: canNavigateNext,
        content: "Future dates are out of range",
        enterDelay: 0,
        leaveDelay: 0,
        children: /* @__PURE__ */ jsxRuntime.jsx(core.Button, {
          disabled: !canNavigateNext,
          appearance: "transparent",
          sentiment: "neutral",
          onClick: handleNavigateNext,
          focusableWhenDisabled: true,
          children: /* @__PURE__ */ jsxRuntime.jsx(NextIcon, {
            "aria-label": "Next Month"
          })
        })
      })
    ]
  });
});

exports.CalendarNavigation = CalendarNavigation;
//# sourceMappingURL=CalendarNavigation.js.map
