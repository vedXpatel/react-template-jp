'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var date = require('@internationalized/date');
var core = require('@salt-ds/core');
var react = require('react');
var formatDate = require('./formatDate.js');
var utils = require('./internal/utils.js');
var useCalendarSelection = require('./useCalendarSelection.js');

const defaultIsDayUnselectable = () => false;
const defaultIsDayHighlighted = () => false;
const defaultIsDayDisabled = () => false;
function useCalendar(props) {
  const {
    selectedDate,
    defaultSelectedDate,
    visibleMonth: visibleMonthProp,
    hideOutOfRangeDates,
    timeZone = date.getLocalTimeZone(),
    locale = formatDate.getCurrentLocale(),
    defaultVisibleMonth = date.today(timeZone),
    onSelectedDateChange,
    onVisibleMonthChange,
    isDayUnselectable = defaultIsDayUnselectable,
    isDayHighlighted = defaultIsDayHighlighted,
    isDayDisabled = defaultIsDayDisabled,
    minDate,
    maxDate,
    selectionVariant,
    onHoveredDateChange,
    hoveredDate
  } = props;
  const [visibleMonth, setVisibleMonthState] = core.useControlled({
    controlled: visibleMonthProp ? date.startOfMonth(visibleMonthProp) : void 0,
    default: date.startOfMonth(defaultVisibleMonth),
    name: "Calendar",
    state: "visibleMonth"
  });
  const isOutsideAllowedDates = react.useCallback(
    (date) => {
      return minDate && date.compare(minDate) < 0 || maxDate && date.compare(maxDate) > 0;
    },
    [maxDate, minDate]
  );
  const isOutsideAllowedMonths = react.useCallback(
    (date$1) => {
      return minDate && date.endOfMonth(date$1).compare(minDate) < 0 || maxDate && date.startOfMonth(date$1).compare(maxDate) > 0;
    },
    [minDate, maxDate]
  );
  const isOutsideAllowedYears = react.useCallback(
    (date$1) => {
      return minDate && date.endOfYear(date$1).compare(minDate) < 0 || maxDate && date.startOfYear(date$1).compare(maxDate) > 0;
    },
    [minDate, maxDate]
  );
  const isDaySelectable = react.useCallback(
    (date) => !(date && (isDayUnselectable(date) || isDayDisabled(date) || isOutsideAllowedDates(date))),
    [isDayUnselectable, isDayDisabled, isOutsideAllowedDates]
  );
  const selectionManager = useCalendarSelection.useCalendarSelection({
    defaultSelectedDate,
    selectedDate,
    onSelectedDateChange,
    startDateOffset: props.selectionVariant === "offset" ? props.startDateOffset : void 0,
    endDateOffset: props.selectionVariant === "offset" ? props.endDateOffset : void 0,
    isDaySelectable,
    selectionVariant,
    onHoveredDateChange,
    hoveredDate
  });
  const [calendarFocused, setCalendarFocused] = react.useState(false);
  const isInVisibleMonth = react.useCallback(
    (date$1) => date$1 != null && date.isSameMonth(date$1, visibleMonth),
    [visibleMonth]
  );
  const getInitialFocusedDate = react.useCallback(() => {
    const selectedDate2 = selectionManager.state.selectedDate;
    if ((selectionVariant === "range" || selectionVariant === "offset") && useCalendarSelection.isDateRangeSelection(selectedDate2)) {
      if (isInVisibleMonth(selectedDate2 == null ? void 0 : selectedDate2.startDate)) {
        return selectedDate2.startDate;
      }
      if (isInVisibleMonth(selectedDate2 == null ? void 0 : selectedDate2.endDate)) {
        return selectedDate2.endDate;
      }
    } else if (selectionVariant === "multiselect" && Array.isArray(selectedDate2)) {
      const selectionInMonth = selectedDate2.filter((day) => isInVisibleMonth(day)).sort((a, b) => a.compare(b));
      if (selectionInMonth.length > 0) {
        return selectionInMonth[0];
      }
    } else if (selectionVariant === "single" && !useCalendarSelection.isDateRangeSelection(selectedDate2) && !Array.isArray(selectedDate2) && isInVisibleMonth(selectedDate2)) {
      return selectedDate2;
    }
    if (isDaySelectable(date.today(timeZone)) && isInVisibleMonth(date.today(timeZone))) {
      return date.today(timeZone);
    }
    const firstSelectableDate = utils.generateDatesForMonth(visibleMonth).find(
      (visibleDay) => isDaySelectable(visibleDay)
    );
    if (firstSelectableDate) {
      return firstSelectableDate;
    }
    return null;
  }, [
    isInVisibleMonth,
    selectionVariant,
    selectionManager.state.selectedDate,
    timeZone,
    visibleMonth
  ]);
  const [focusedDate, setFocusedDateState] = react.useState(
    getInitialFocusedDate
  );
  const isDayVisible = react.useCallback(
    (date$1) => {
      const startInsideDays = date.startOfMonth(visibleMonth);
      if (date$1.compare(startInsideDays) < 0)
        return false;
      const endInsideDays = date.endOfMonth(visibleMonth);
      return !(date$1.compare(endInsideDays) > 0);
    },
    [visibleMonth]
  );
  const setVisibleMonth = react.useCallback(
    (event, newVisibleMonth) => {
      setVisibleMonthState(newVisibleMonth);
      onVisibleMonthChange == null ? void 0 : onVisibleMonthChange(event, newVisibleMonth);
    },
    [onVisibleMonthChange]
  );
  const setFocusedDate = react.useCallback(
    (event, date$1) => {
      if (!focusedDate || date.isSameDay(date$1, focusedDate) || isOutsideAllowedDates(date$1))
        return;
      setFocusedDateState(date$1);
      const shouldTransition = !isDayVisible(date$1) && isDaySelectable(date$1) && !isOutsideAllowedDates(date$1);
      if (shouldTransition) {
        setVisibleMonth(event, date.startOfMonth(date$1));
      }
    },
    [
      focusedDate,
      isDaySelectable,
      isDayVisible,
      isOutsideAllowedDates,
      setVisibleMonth
    ]
  );
  react.useEffect(() => {
    if (visibleMonth && focusedDate && !isDayVisible(focusedDate)) {
      const focusableDate = getInitialFocusedDate();
      if (focusableDate) {
        setFocusedDateState(focusableDate);
      }
    }
  }, [isDayVisible, focusedDate, getInitialFocusedDate, visibleMonth]);
  return react.useMemo(
    () => ({
      state: {
        visibleMonth,
        focusedDate,
        minDate,
        maxDate,
        selectionVariant,
        hideOutOfRangeDates,
        calendarFocused,
        timeZone,
        locale,
        ...selectionManager.state
      },
      helpers: {
        setVisibleMonth,
        setFocusedDate,
        setCalendarFocused,
        isDayUnselectable,
        isDayHighlighted,
        isDayDisabled,
        isDayVisible,
        isOutsideAllowedDates,
        isOutsideAllowedMonths,
        isOutsideAllowedYears,
        ...selectionManager.helpers
      }
    }),
    [
      visibleMonth,
      focusedDate,
      minDate,
      maxDate,
      selectionVariant,
      hideOutOfRangeDates,
      calendarFocused,
      timeZone,
      locale,
      setVisibleMonth,
      setFocusedDate,
      isDayUnselectable,
      isDayHighlighted,
      isDayDisabled,
      isDayVisible,
      isOutsideAllowedDates,
      isOutsideAllowedMonths,
      isOutsideAllowedYears,
      selectionManager
    ]
  );
}

exports.useCalendar = useCalendar;
//# sourceMappingURL=useCalendar.js.map
