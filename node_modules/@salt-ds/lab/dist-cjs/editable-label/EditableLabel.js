'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var core = require('@salt-ds/core');
var clsx = require('clsx');
var react = require('react');
var InputLegacy = require('../input-legacy/InputLegacy.js');
require('../input-legacy/StaticInputAdornment.js');
var styles = require('@salt-ds/styles');
var window = require('@salt-ds/window');
var EditableLabel$1 = require('./EditableLabel.css.js');

const classBase = "saltEditableLabel";
const EditableLabel = react.forwardRef(function EditableLabel2({
  className: classNameProp,
  defaultEditing,
  defaultValue,
  editing: editingProp,
  onChange,
  onEnterEditMode,
  onExitEditMode,
  value: valueProp
}, forwardedRef) {
  const targetWindow = window.useWindow();
  styles.useComponentCssInjection({
    testId: "salt-editable-label",
    css: EditableLabel$1,
    window: targetWindow
  });
  const inputRef = react.useRef(null);
  const [value, setValue] = core.useControlled({
    controlled: valueProp,
    default: defaultValue != null ? defaultValue : "",
    name: "EditableLabel",
    state: "value"
  });
  const [editing, setEditing] = core.useControlled({
    controlled: editingProp,
    default: defaultEditing || false,
    name: "EditableLabel",
    state: "editing"
  });
  const initialValue = react.useRef(value);
  core.useIsomorphicLayoutEffect(() => {
    if (editing) {
      if (inputRef.current !== null) {
        inputRef.current.select();
        inputRef.current.focus();
      }
    }
  }, [editing]);
  const enterEditMode = react.useCallback(() => {
    setEditing(true);
    onEnterEditMode == null ? void 0 : onEnterEditMode();
  }, [onEnterEditMode]);
  const exitEditMode = ({
    cancelEdit = false,
    allowDeactivation = false
  } = {}) => {
    setEditing(false);
    const originalValue = initialValue.current;
    if (originalValue !== value) {
      if (cancelEdit) {
        setValue(originalValue);
      } else {
        initialValue.current = value;
      }
    }
    onExitEditMode == null ? void 0 : onExitEditMode(originalValue, value, allowDeactivation);
  };
  const handleChange = (evt) => {
    const { value: value2 } = evt.target;
    setValue(value2);
    onChange == null ? void 0 : onChange(value2);
  };
  const handleDoubleClick = () => {
    enterEditMode();
  };
  const handleBlur = () => {
    exitEditMode({ allowDeactivation: true });
  };
  const handleKeyDown = (evt) => {
    if (editing && evt.key === "Enter") {
      evt.stopPropagation();
      exitEditMode();
    } else if (evt.key === "ArrowRight" || evt.key === "ArrowLeft") {
      evt.stopPropagation();
    } else if (evt.key === "Escape") {
      exitEditMode({ cancelEdit: true });
    }
  };
  const className = clsx.clsx(classBase, classNameProp, {
    [`${classBase}-editing`]: editing
  });
  return /* @__PURE__ */ jsxRuntime.jsx("div", {
    className,
    onDoubleClick: handleDoubleClick,
    "data-text": value,
    ref: forwardedRef,
    children: editing ? /* @__PURE__ */ jsxRuntime.jsx(InputLegacy.InputLegacy, {
      inputProps: { className: `${classBase}-input` },
      value,
      onBlur: handleBlur,
      onChange: handleChange,
      onKeyDown: handleKeyDown,
      ref: inputRef,
      style: { padding: 0 },
      textAlign: "left"
    }) : value
  });
});

exports.EditableLabel = EditableLabel;
//# sourceMappingURL=EditableLabel.js.map
