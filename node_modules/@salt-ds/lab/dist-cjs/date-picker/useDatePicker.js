'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var date = require('@internationalized/date');
var core = require('@salt-ds/core');
var react = require('react');
require('../calendar/Calendar.js');
require('../calendar/CalendarNavigation.js');
require('../calendar/CalendarWeekHeader.js');
require('../calendar/CalendarDateGrid.js');
require('../calendar/internal/CalendarContext.js');
var formatDate = require('../calendar/formatDate.js');
var useCalendarSelection = require('../calendar/useCalendarSelection.js');
var DatePickerOverlayProvider = require('./DatePickerOverlayProvider.js');

function useDatePicker(props, ref) {
  const {
    readOnly = false,
    disabled,
    selectionVariant,
    defaultSelectedDate = null,
    selectedDate: selectedDateProp,
    onSelectedDateChange,
    onApply,
    minDate: minDateProp,
    maxDate: maxDateProp,
    timeZone = date.getLocalTimeZone(),
    locale = formatDate.getCurrentLocale(),
    onCancel
  } = props;
  const minDate = react.useMemo(
    () => minDateProp != null ? minDateProp : date.startOfMonth(new date.CalendarDate(useCalendarSelection.CALENDAR_MIN_YEAR, 1, 1)),
    [minDateProp]
  );
  const maxDate = react.useMemo(
    () => maxDateProp != null ? maxDateProp : date.endOfMonth(new date.CalendarDate(useCalendarSelection.CALENDAR_MAX_YEAR, 1, 1)),
    [maxDateProp]
  );
  const datePickerRef = react.useRef(null);
  const containerRef = core.useForkRef(ref, datePickerRef);
  const {
    state: { open },
    helpers: { setOpen }
  } = DatePickerOverlayProvider.useDatePickerOverlay();
  const [selectedDate, setSelectedDate] = core.useControlled({
    controlled: selectedDateProp,
    default: defaultSelectedDate,
    name: "DatePicker",
    state: "selectedDate"
  });
  const [enableApply, setEnableApply] = react.useState(false);
  const [cancelled, setCancelled] = react.useState(false);
  react.useEffect(() => {
    if (open) {
      setCancelled(false);
    }
  }, [open]);
  const { disabled: formFieldDisabled, readOnly: formFieldReadOnly } = core.useFormFieldProps();
  const isReadOnly = readOnly || formFieldReadOnly || false;
  const isDisabled = disabled || formFieldDisabled || false;
  const applySingle = (appliedDate, error) => {
    setCancelled(false);
    setOpen(false);
    if (selectionVariant === "single") {
      onApply == null ? void 0 : onApply(appliedDate, error);
    }
  };
  const setSelectedSingleDate = react.useCallback(
    (selection, error) => {
      let nextDate;
      if (error || !selection) {
        nextDate = selection;
      } else {
        let dateAfterMinDate = true;
        let dateBeforeMaxDate = true;
        if (minDate && selection) {
          dateAfterMinDate = selection.compare(minDate) >= 0;
        }
        if (maxDate && selection) {
          dateBeforeMaxDate = selection.compare(maxDate) <= 0;
        }
        nextDate = dateAfterMinDate && dateBeforeMaxDate ? selection : null;
      }
      setSelectedDate(nextDate);
      if (selectionVariant === "single") {
        onSelectedDateChange == null ? void 0 : onSelectedDateChange(nextDate, error);
      }
      if (!enableApply) {
        setOpen(false);
      }
    },
    [
      enableApply,
      minDate,
      maxDate,
      onSelectedDateChange,
      selectionVariant,
      setSelectedDate,
      setOpen
    ]
  );
  const applyRange = (appliedDate, error) => {
    setCancelled(false);
    if ((appliedDate == null ? void 0 : appliedDate.startDate) && (appliedDate == null ? void 0 : appliedDate.endDate)) {
      setOpen(false);
    }
    if (selectionVariant === "range") {
      onApply == null ? void 0 : onApply(appliedDate, error);
    }
  };
  const setSelectedRangeDate = react.useCallback(
    (selection, error) => {
      let nextDate;
      let nextError = { ...error };
      let startDateInRange = true;
      let endDateInRange = true;
      if ((error == null ? void 0 : error.startDate) || (error == null ? void 0 : error.endDate) || !selection) {
        nextDate = selection;
      } else {
        if (maxDate && (selection == null ? void 0 : selection.startDate)) {
          startDateInRange = selection.startDate.compare(minDate) >= 0;
        }
        if (maxDate && (selection == null ? void 0 : selection.endDate)) {
          endDateInRange = (selection == null ? void 0 : selection.endDate) && selection.endDate.compare(maxDate) <= 0;
        }
        if (!startDateInRange && !endDateInRange) {
          nextDate = null;
          nextError = {
            startDate: "is before min date",
            endDate: "is after max date"
          };
        } else {
          nextDate = {
            startDate: selection.startDate || null,
            endDate: selection.endDate || null
          };
          nextError = {
            startDate: !startDateInRange ? "is before min date" : nextError.startDate,
            endDate: !endDateInRange ? "is after max date" : nextError.endDate
          };
        }
      }
      setSelectedDate(nextDate);
      if (selectionVariant === "range") {
        onSelectedDateChange == null ? void 0 : onSelectedDateChange(nextDate, nextError);
      }
      if (!enableApply && (nextDate == null ? void 0 : nextDate.startDate) && (nextDate == null ? void 0 : nextDate.endDate)) {
        setOpen(false);
      }
    },
    [
      enableApply,
      minDate,
      maxDate,
      onSelectedDateChange,
      selectionVariant,
      setSelectedDate,
      setOpen
    ]
  );
  const cancel = () => {
    setCancelled(true);
    setOpen(false);
    onCancel == null ? void 0 : onCancel();
  };
  const returnValue = {
    state: {
      selectionVariant,
      selectedDate,
      cancelled,
      enableApply,
      disabled: isDisabled,
      readOnly: isReadOnly,
      containerRef,
      minDate,
      maxDate,
      locale,
      timeZone
    },
    helpers: {
      cancel,
      setEnableApply
    }
  };
  if (props.selectionVariant === "range") {
    return {
      ...returnValue,
      helpers: {
        ...returnValue.helpers,
        apply: applyRange,
        setSelectedDate: setSelectedRangeDate
      }
    };
  }
  return {
    ...returnValue,
    helpers: {
      ...returnValue.helpers,
      apply: applySingle,
      setSelectedDate: setSelectedSingleDate
    }
  };
}

exports.useDatePicker = useDatePicker;
//# sourceMappingURL=useDatePicker.js.map
