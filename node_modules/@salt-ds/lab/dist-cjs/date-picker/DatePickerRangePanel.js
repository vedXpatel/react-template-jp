'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var date = require('@internationalized/date');
var core = require('@salt-ds/core');
var styles = require('@salt-ds/styles');
var window = require('@salt-ds/window');
var clsx = require('clsx');
var react = require('react');
var Calendar = require('../calendar/Calendar.js');
var CalendarNavigation = require('../calendar/CalendarNavigation.js');
var CalendarWeekHeader = require('../calendar/CalendarWeekHeader.js');
var CalendarDateGrid = require('../calendar/CalendarDateGrid.js');
require('../calendar/internal/CalendarContext.js');
var formatDate = require('../calendar/formatDate.js');
require('../calendar/useCalendarSelection.js');
var DatePickerContext = require('./DatePickerContext.js');
var DatePickerPanel = require('./DatePickerPanel.css.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var clsx__default = /*#__PURE__*/_interopDefaultLegacy(clsx);

function getFallbackVisibleMonths(selectedDate, timeZone) {
  const createConsecutiveRange = (date$1) => [
    date.startOfMonth(date$1),
    date.startOfMonth(date$1).add({ months: 1 })
  ];
  if (selectedDate == null ? void 0 : selectedDate.startDate) {
    const { startDate, endDate } = selectedDate;
    if (endDate) {
      return date.isSameMonth(startDate, endDate) ? createConsecutiveRange(startDate) : [date.startOfMonth(startDate), date.startOfMonth(endDate)];
    }
    return createConsecutiveRange(startDate);
  }
  const currentMonth = date.startOfMonth(date.today(timeZone));
  return [currentMonth, currentMonth.add({ months: 1 })];
}
const withBaseName = core.makePrefixer("saltDatePickerPanel");
const DatePickerRangePanel = react.forwardRef(function DatePickerRangePanel2(props, ref) {
  const {
    className,
    defaultStartVisibleMonth: defaultStartVisibleMonthProp,
    startVisibleMonth: startVisibleMonthProp,
    onStartVisibleMonthChange,
    defaultEndVisibleMonth: defaultEndVisibleMonthProp,
    endVisibleMonth: endVisibleMonthProp,
    onEndVisibleMonthChange,
    helperText,
    onSelect,
    StartCalendarProps: StartCalendarPropsProp,
    StartCalendarNavigationProps,
    StartCalendarWeekHeaderProps,
    StartCalendarDataGridProps,
    EndCalendarProps: EndCalendarPropsProp,
    EndCalendarNavigationProps,
    EndCalendarWeekHeaderProps,
    EndCalendarDataGridProps,
    ...rest
  } = props;
  const targetWindow = window.useWindow();
  styles.useComponentCssInjection({
    testId: "salt-date-picker-range-panel",
    css: DatePickerPanel,
    window: targetWindow
  });
  const {
    state: {
      selectedDate,
      timeZone = date.getLocalTimeZone(),
      minDate = date.startOfMonth(date.today(timeZone)),
      maxDate = minDate.add({ months: 1 }),
      locale = formatDate.getCurrentLocale()
    },
    helpers: { setSelectedDate }
  } = DatePickerContext.useDatePickerContext({ selectionVariant: "range" });
  const [hoveredDate, setHoveredDate] = react.useState(null);
  const [[fallbackStartVisibleMonth, fallbackEndVisibleMonth]] = react.useState(
    () => getFallbackVisibleMonths(selectedDate, timeZone)
  );
  const [startVisibleMonth, setStartVisibleMonth] = core.useControlled({
    controlled: startVisibleMonthProp,
    default: defaultStartVisibleMonthProp || fallbackStartVisibleMonth,
    name: "DatePickerRangePanel",
    state: "startVisibleMonth"
  });
  const [endVisibleMonth, setEndVisibleMonth] = core.useControlled({
    controlled: endVisibleMonthProp,
    default: defaultEndVisibleMonthProp || fallbackEndVisibleMonth,
    name: "DatePickerRangePanel",
    state: "endVisibleMonth"
  });
  const handleSelectedDateChange = react.useCallback(
    (event, newDate) => {
      setSelectedDate(newDate, { startDate: false, endDate: false });
      onSelect == null ? void 0 : onSelect(event, newDate);
    },
    [onSelect, setSelectedDate]
  );
  const handleHoveredStartDateChange = react.useCallback(
    (event, newHoveredDate) => {
      var _a;
      setHoveredDate(newHoveredDate);
      if (newHoveredDate && (StartCalendarPropsProp == null ? void 0 : StartCalendarPropsProp.onHoveredDateChange)) {
        (_a = StartCalendarPropsProp.onHoveredDateChange) == null ? void 0 : _a.call(StartCalendarPropsProp, event, newHoveredDate);
      }
    },
    [StartCalendarPropsProp == null ? void 0 : StartCalendarPropsProp.onHoveredDateChange]
  );
  const handleHoveredEndDateChange = react.useCallback(
    (event, newHoveredDate) => {
      setHoveredDate(newHoveredDate);
      if (newHoveredDate && (EndCalendarPropsProp == null ? void 0 : EndCalendarPropsProp.onHoveredDateChange)) {
        EndCalendarPropsProp.onHoveredDateChange(event, newHoveredDate);
      }
    },
    [EndCalendarPropsProp == null ? void 0 : EndCalendarPropsProp.onHoveredDateChange]
  );
  const handleStartVisibleMonthChange = react.useCallback(
    (event, newVisibleMonth) => {
      setStartVisibleMonth(newVisibleMonth);
      if (newVisibleMonth.compare(endVisibleMonth) >= 0) {
        setEndVisibleMonth(newVisibleMonth.add({ months: 1 }));
      }
      onStartVisibleMonthChange == null ? void 0 : onStartVisibleMonthChange(event, newVisibleMonth);
    },
    [endVisibleMonth, onStartVisibleMonthChange]
  );
  const handleEndVisibleMonthChange = react.useCallback(
    (event, newVisibleMonth) => {
      setEndVisibleMonth(newVisibleMonth);
      if (newVisibleMonth.compare(startVisibleMonth) <= 0) {
        setStartVisibleMonth(
          date.startOfMonth(newVisibleMonth.subtract({ months: 1 }))
        );
      }
      onEndVisibleMonthChange == null ? void 0 : onEndVisibleMonthChange(event, newVisibleMonth);
    },
    [startVisibleMonth, onEndVisibleMonthChange]
  );
  function getHoveredDate(date$1, hoveredDate2) {
    return date$1 && hoveredDate2 && (hoveredDate2 == null ? void 0 : hoveredDate2.compare(date.endOfMonth(date$1))) > 0 ? date.endOfMonth(date$1) : hoveredDate2;
  }
  const StartCalendarProps = {
    visibleMonth: startVisibleMonth,
    hoveredDate: getHoveredDate(selectedDate == null ? void 0 : selectedDate.startDate, hoveredDate),
    selectedDate,
    onHoveredDateChange: handleHoveredStartDateChange,
    onVisibleMonthChange: handleStartVisibleMonthChange,
    onSelectedDateChange: handleSelectedDateChange,
    hideOutOfRangeDates: true,
    minDate,
    maxDate,
    locale,
    timeZone,
    ...StartCalendarPropsProp
  };
  const EndCalendarProps = {
    visibleMonth: endVisibleMonth,
    hoveredDate,
    selectedDate,
    onHoveredDateChange: handleHoveredEndDateChange,
    onVisibleMonthChange: handleEndVisibleMonthChange,
    onSelectedDateChange: handleSelectedDateChange,
    hideOutOfRangeDates: true,
    minDate,
    maxDate,
    locale,
    timeZone,
    ...EndCalendarPropsProp
  };
  return /* @__PURE__ */ jsxRuntime.jsxs(core.StackLayout, {
    separators: true,
    gap: 0,
    className: clsx__default["default"](className, withBaseName("container")),
    ref,
    ...rest,
    children: [
      helperText && /* @__PURE__ */ jsxRuntime.jsx(core.FlexItem, {
        className: withBaseName("header"),
        children: /* @__PURE__ */ jsxRuntime.jsx(core.FormFieldHelperText, {
          children: helperText
        })
      }),
      /* @__PURE__ */ jsxRuntime.jsx(core.FlexLayout, {
        gap: 0,
        children: /* @__PURE__ */ jsxRuntime.jsxs(core.FormFieldContext.Provider, {
          value: {},
          children: [
            /* @__PURE__ */ jsxRuntime.jsxs(Calendar.Calendar, {
              selectionVariant: "range",
              ...StartCalendarProps,
              children: [
                /* @__PURE__ */ jsxRuntime.jsx(CalendarNavigation.CalendarNavigation, {
                  ...StartCalendarNavigationProps
                }),
                /* @__PURE__ */ jsxRuntime.jsx(CalendarWeekHeader.CalendarWeekHeader, {
                  ...StartCalendarWeekHeaderProps
                }),
                /* @__PURE__ */ jsxRuntime.jsx(CalendarDateGrid.CalendarDateGrid, {
                  ...StartCalendarDataGridProps
                })
              ]
            }),
            /* @__PURE__ */ jsxRuntime.jsxs(Calendar.Calendar, {
              selectionVariant: "range",
              ...EndCalendarProps,
              children: [
                /* @__PURE__ */ jsxRuntime.jsx(CalendarNavigation.CalendarNavigation, {
                  ...EndCalendarNavigationProps
                }),
                /* @__PURE__ */ jsxRuntime.jsx(CalendarWeekHeader.CalendarWeekHeader, {
                  ...EndCalendarWeekHeaderProps
                }),
                /* @__PURE__ */ jsxRuntime.jsx(CalendarDateGrid.CalendarDateGrid, {
                  ...EndCalendarDataGridProps
                })
              ]
            })
          ]
        })
      })
    ]
  });
});

exports.DatePickerRangePanel = DatePickerRangePanel;
//# sourceMappingURL=DatePickerRangePanel.js.map
