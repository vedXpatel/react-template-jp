'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@salt-ds/core');
var react = require('react');
var keyset = require('./keyset.js');

const byKey = ([k1], [k2]) => k1 - k2;
const renderBuffer = 5;
const useVirtualization = ({
  viewportRef,
  data,
  itemGapSize = 0
}) => {
  const viewportMeasures = react.useRef({
    contentHeight: 1e4,
    firstVisibleRow: 0,
    rowCount: 0,
    rowHeight: 0,
    scrollPos: 0
  });
  const [rows, setRows] = react.useState([]);
  const keys = react.useMemo(() => new keyset.KeySet(0, 1), []);
  const updateRows = react.useCallback(
    (from, to) => {
      const { rowHeight } = viewportMeasures.current;
      const rowHeightWithGap = rowHeight + itemGapSize;
      const lo = Math.max(0, from - renderBuffer);
      const hi = Math.min(data.length, to + renderBuffer);
      keys.reset(lo, hi);
      const newRows = data.slice(lo, hi).map(
        (value, idx) => [
          keys.keyFor(idx + lo),
          (idx + lo) * rowHeightWithGap,
          idx + lo + 1,
          value
        ]
      ).sort(byKey);
      setRows(newRows);
    },
    [data, itemGapSize, keys]
  );
  core.useIsomorphicLayoutEffect(() => {
    const viewport = viewportMeasures.current;
    const viewportEl = viewportRef.current;
    if (viewportEl) {
      const listItemEl = viewportEl.querySelector(".saltListItem");
      if (listItemEl) {
        const { height: viewportHeight } = viewportEl.getBoundingClientRect();
        const { height: rowHeight } = listItemEl.getBoundingClientRect();
        viewport.rowHeight = rowHeight;
        viewport.rowCount = Math.ceil(viewportHeight / rowHeight);
        viewport.contentHeight = (rowHeight + itemGapSize) * data.length;
        updateRows(0, viewport.rowCount);
      }
    }
  }, [data, itemGapSize, updateRows, viewportRef]);
  const handleVerticalScroll = react.useCallback(
    (e) => {
      const viewport = viewportMeasures.current;
      const scrollTop = e.target.scrollTop;
      if (scrollTop !== viewport.scrollPos) {
        viewport.scrollPos = scrollTop;
        const firstRow = Math.floor(scrollTop / viewport.rowHeight);
        if (firstRow !== viewport.firstVisibleRow) {
          viewport.firstVisibleRow = firstRow;
          const from = firstRow;
          const to = firstRow + viewport.rowCount;
          updateRows(from, to);
        }
      }
    },
    [updateRows]
  );
  return {
    rows,
    contentHeight: viewportMeasures.current.contentHeight,
    onVerticalScroll: handleVerticalScroll
  };
};

exports.useVirtualization = useVirtualization;
//# sourceMappingURL=useVirtualization.js.map
