'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');
var Draggable = require('./Draggable.js');

const useDragSpacers = () => {
  const animationFrame = react.useRef(0);
  const transitioning = react.useRef(false);
  const spacers = react.useMemo(
    () => [Draggable.createDragSpacer(transitioning), Draggable.createDragSpacer()],
    []
  );
  const clearSpacers = react.useCallback(
    () => spacers.forEach((spacer) => {
      var _a;
      return (_a = spacer.parentElement) == null ? void 0 : _a.removeChild(spacer);
    }),
    [spacers]
  );
  const animateTransition = react.useCallback(
    (size) => {
      const [spacer1, spacer2] = spacers;
      animationFrame.current = requestAnimationFrame(() => {
        transitioning.current = true;
        spacer1.style.cssText = "width: 0px";
        spacer2.style.cssText = `width: ${size}px`;
        spacers[0] = spacer2;
        spacers[1] = spacer1;
      });
    },
    [spacers]
  );
  const cancelAnyPendingAnimation = react.useCallback(() => {
    if (animationFrame.current) {
      cancelAnimationFrame(animationFrame.current);
      animationFrame.current = 0;
    }
  }, []);
  const displaceItem = react.useCallback(
    (item, size, useTransition = false, direction) => {
      var _a, _b, _c, _d;
      if (item) {
        const [spacer1, spacer2] = spacers;
        cancelAnyPendingAnimation();
        if (useTransition) {
          if (transitioning.current) {
            clearSpacers();
            spacer1.style.cssText = `width: ${size}px`;
            spacer2.style.cssText = "width: 0px";
            const target = direction === "fwd" ? item.element.previousElementSibling : item.element.nextElementSibling;
            (_a = item.element.parentElement) == null ? void 0 : _a.insertBefore(spacer1, target);
            (_b = item.element.parentElement) == null ? void 0 : _b.insertBefore(spacer2, item.element);
          } else {
            (_c = item.element.parentElement) == null ? void 0 : _c.insertBefore(spacer2, item.element);
          }
          animateTransition(size);
        } else {
          spacer1.style.cssText = `width: ${size}px`;
          (_d = item.element.parentElement) == null ? void 0 : _d.insertBefore(spacer1, item.element);
        }
      }
    },
    [animateTransition, cancelAnyPendingAnimation, clearSpacers, spacers]
  );
  const displaceLastItem = react.useCallback(
    (item, size, useTransition = false) => {
      var _a, _b, _c, _d;
      const [spacer1, spacer2] = spacers;
      cancelAnyPendingAnimation();
      if (useTransition) {
        if (transitioning.current) {
          clearSpacers();
          spacer1.style.cssText = `width: ${size}px`;
          spacer2.style.cssText = "width: 0px";
          (_a = item.element.parentElement) == null ? void 0 : _a.insertBefore(
            spacer1,
            item.element.previousElementSibling
          );
          (_b = item.element.parentElement) == null ? void 0 : _b.insertBefore(
            spacer2,
            item.element.nextElementSibling
          );
        } else {
          (_c = item.element.parentElement) == null ? void 0 : _c.insertBefore(
            spacer2,
            item.element.nextElementSibling
          );
        }
        animateTransition(size);
      } else {
        spacer1.style.cssText = `width: ${size}px`;
        (_d = item.element.parentElement) == null ? void 0 : _d.insertBefore(
          spacer1,
          item.element.nextElementSibling
        );
      }
    },
    [animateTransition, cancelAnyPendingAnimation, clearSpacers, spacers]
  );
  return {
    displaceItem,
    displaceLastItem,
    clearSpacers
  };
};

exports.useDragSpacers = useDragSpacers;
//# sourceMappingURL=useDragSpacers.js.map
