'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var dragDropTypes = require('./dragDropTypes.js');

const LEFT_RIGHT = ["left", "right"];
const TOP_BOTTOM = ["top", "bottom"];
const measureElementSizeAndPosition = (element, dimension = "width", includeAutoMargin = false) => {
  const pos = dimension === "width" ? "left" : "top";
  const { [dimension]: size, [pos]: position } = element.getBoundingClientRect();
  const { padEnd = false, padStart = false } = element.dataset;
  const style = getComputedStyle(element);
  const [start, end] = dimension === "width" ? LEFT_RIGHT : TOP_BOTTOM;
  const marginStart = padStart && !includeAutoMargin ? 0 : Number.parseInt(style.getPropertyValue(`margin-${start}`), 10);
  const marginEnd = padEnd && !includeAutoMargin ? 0 : Number.parseInt(style.getPropertyValue(`margin-${end}`), 10);
  let minWidth = size;
  const flexShrink = Number.parseInt(style.getPropertyValue("flex-shrink"), 10);
  if (flexShrink > 0) {
    const flexBasis = Number.parseInt(style.getPropertyValue("flex-basis"), 10);
    if (!Number.isNaN(flexBasis) && flexBasis > 0) {
      minWidth = flexBasis;
    }
  }
  return [position, marginStart + minWidth + marginEnd];
};
const DIMENSIONS = {
  horizontal: {
    CLIENT_SIZE: "clientWidth",
    CONTRA: "top",
    CONTRA_POS: "clientY",
    DIMENSION: "width",
    END: "right",
    POS: "clientX",
    SCROLL_POS: "scrollTop",
    SCROLL_SIZE: "scrollWidth",
    START: "left"
  },
  vertical: {
    CLIENT_SIZE: "clientHeight",
    CONTRA: "left",
    CONTRA_POS: "clientX",
    DIMENSION: "height",
    END: "bottom",
    POS: "clientY",
    SCROLL_POS: "scrollLeft",
    SCROLL_SIZE: "scrollHeight",
    START: "top"
  }
};
const dimensions = (orientation) => DIMENSIONS[orientation];
const getDraggedItem = (measuredItems) => {
  const result = measuredItems.find((item) => item.isDraggedElement);
  if (result) {
    return result;
  }
  throw Error("measuredItems do not contain a draggedElement");
};
const moveDragItem = (measuredItems, dropTarget) => {
  const items = measuredItems.slice();
  const draggedItem = getDraggedItem(items);
  const draggedIndex = items.indexOf(draggedItem);
  const targetIndex = items.indexOf(dropTarget);
  const firstPos = Math.min(draggedIndex, targetIndex);
  const lastPos = Math.max(draggedIndex, targetIndex);
  let { start } = items[firstPos];
  items[draggedIndex] = { ...dropTarget };
  items[targetIndex] = { ...draggedItem };
  for (let i = firstPos; i <= lastPos; i++) {
    const item = items[i];
    item.currentIndex = i;
    item.start = start;
    item.end = start + item.size;
    item.mid = start + item.size / 2;
    start = item.end;
  }
  return items;
};
const isDraggedElement = (item) => item.isDraggedElement;
const measureDropTargets = (container, orientation, draggedItem, itemQuery) => {
  var _a;
  const dragThresholds = [];
  const children = Array.from(
    itemQuery ? container.querySelectorAll(itemQuery) : container.children
  );
  let previousThreshold = null;
  for (let index = 0; index < children.length; index++) {
    const element = children[index];
    const dimension = orientation === "horizontal" ? "width" : "height";
    const [start, size] = measureElementSizeAndPosition(element, dimension);
    previousThreshold = {
      currentIndex: index,
      dataIndex: Number.parseInt((_a = element.dataset.index) != null ? _a : "-1"),
      index,
      isDraggedElement: element === draggedItem,
      isOverflowIndicator: element.dataset.overflowIndicator === "true",
      element,
      start,
      end: start + size,
      size,
      mid: start + size / 2
    };
    dragThresholds.push(previousThreshold);
  }
  return dragThresholds;
};
const getNextDropTarget = (dropTargets, pos, direction) => {
  const len = dropTargets.length;
  if (direction === dragDropTypes.FWD) {
    for (let index = 0; index < len; index++) {
      let dropTarget = dropTargets[index];
      const { start, mid, end } = dropTarget;
      if (pos > end) {
        continue;
      }
      if (pos > mid) {
        return dropTarget.isDraggedElement ? null : dropTarget;
      }
      if (pos > start) {
        dropTarget = dropTargets[index - 1];
        return dropTarget.isDraggedElement ? null : dropTarget;
      }
    }
  } else {
    for (let index = len - 1; index >= 0; index--) {
      let dropTarget = dropTargets[index];
      const { start, mid, end } = dropTarget;
      if (pos < start) {
        continue;
      }
      if (pos < mid) {
        return dropTarget.isDraggedElement ? null : dropTarget;
      }
      if (pos < end) {
        dropTarget = dropTargets[Math.min(len - 1, index + 1)];
        return dropTarget.isDraggedElement ? null : dropTarget;
      }
    }
  }
  return null;
};

exports.dimensions = dimensions;
exports.getDraggedItem = getDraggedItem;
exports.getNextDropTarget = getNextDropTarget;
exports.isDraggedElement = isDraggedElement;
exports.measureDropTargets = measureDropTargets;
exports.measureElementSizeAndPosition = measureElementSizeAndPosition;
exports.moveDragItem = moveDragItem;
//# sourceMappingURL=drag-utils.js.map
