'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const getValue = (trackRef, min, max, step, clientX) => {
  const { width, x } = trackRef.current.getBoundingClientRect();
  const localX = clientX - x;
  const normaliseBetweenValues = localX / width * (max - min) + min;
  const roundedToStep = roundToStep(normaliseBetweenValues, step);
  const decimals = countDecimalPlaces(step);
  const rounded = Number(roundedToStep.toFixed(decimals));
  const value = clampValue(rounded, [min, max]);
  return value;
};
const setValue = (value, newValue, index, onChange) => {
  if (value.length === 2) {
    const newValueArray = [...value];
    newValueArray.splice(index, 1, newValue);
    onChange(newValueArray);
    return;
  }
  onChange([newValue]);
};
const roundToStep = (value, step) => Math.round(value / step) * step;
const clampValue = (value, [min, max]) => {
  if (value > max) {
    return max;
  }
  if (value < min) {
    return min;
  }
  return value;
};
const getPercentage = (min, max, value) => {
  const percentage = (value - min) / (max - min) * 100;
  return Math.min(Math.max(percentage, 0), 100);
};
const countDecimalPlaces = (num) => {
  const parts = num.toString().split(".");
  return parts.length > 1 ? parts[1].length : 0;
};
const getMarkStyles = (min, max, step) => {
  const marks = [];
  for (let i = min; i <= max; i = Number((i + step).toPrecision(4))) {
    const value = Number(i.toPrecision(4));
    const position = `${getPercentage(min, max, value)}%`;
    marks.push({ value, position });
  }
  const decimals = Math.max(
    ...marks.map((mark) => countDecimalPlaces(mark.value))
  );
  return marks.map((mark) => ({
    ...mark,
    label: mark.value.toFixed(decimals)
  }));
};
const getNearestIndex = (value, newValue) => {
  if (value.length === 1)
    return 0;
  if (value[0] === value[1]) {
    if (newValue < value[0])
      return 0;
    return 1;
  }
  const distances = value.map((value2) => Math.abs(newValue - value2));
  const minDistance = Math.min(...distances);
  const nearestIndex = distances.indexOf(minDistance);
  return nearestIndex;
};
const preventOverlappingValues = (value, newValue, index) => value.length === 2 ? index === 0 ? Math.min(newValue, value[1]) : Math.max(newValue, value[0]) : newValue;
const parseValueProp = (value, min, max) => {
  if (typeof value === "undefined" || value.length < 1)
    return;
  const a = clampValue(value[0], [min, max]);
  if (value.length === 1)
    return [a];
  const b = clampValue(value[1], [min, max]);
  if (a > b)
    return [a, a];
  return [a, b];
};

exports.clampValue = clampValue;
exports.countDecimalPlaces = countDecimalPlaces;
exports.getMarkStyles = getMarkStyles;
exports.getNearestIndex = getNearestIndex;
exports.getPercentage = getPercentage;
exports.getValue = getValue;
exports.parseValueProp = parseValueProp;
exports.preventOverlappingValues = preventOverlappingValues;
exports.roundToStep = roundToStep;
exports.setValue = setValue;
//# sourceMappingURL=utils.js.map
