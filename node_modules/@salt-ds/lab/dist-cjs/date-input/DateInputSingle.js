'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var date = require('@internationalized/date');
var core = require('@salt-ds/core');
var styles = require('@salt-ds/styles');
var window = require('@salt-ds/window');
var clsx = require('clsx');
var react = require('react');
require('../calendar/Calendar.js');
require('../calendar/CalendarNavigation.js');
require('../calendar/CalendarWeekHeader.js');
require('../calendar/CalendarDateGrid.js');
require('../calendar/internal/CalendarContext.js');
var formatDate = require('../calendar/formatDate.js');
require('../calendar/useCalendarSelection.js');
var DateInput = require('./DateInput.css.js');
var utils = require('./utils.js');

const withBaseName = core.makePrefixer("saltDateInput");
const DateInputSingle = react.forwardRef(
  function DateInput$1(props, ref) {
    const {
      bordered = false,
      className,
      disabled,
      "aria-label": ariaLabel,
      date: dateProp,
      defaultDate,
      onDateChange,
      value: valueProp,
      defaultValue = "",
      onChange,
      onClick,
      emptyReadOnlyMarker = "\u2014",
      endAdornment,
      format: formatProp,
      inputProps = {},
      inputRef: inputRefProp = null,
      parse = utils.parseCalendarDate,
      placeholder = "dd mmm yyyy",
      readOnly: readOnlyProp,
      validationStatus: validationStatusProp,
      variant = "primary",
      onDateValueChange,
      locale = formatDate.getCurrentLocale(),
      timeZone = date.getLocalTimeZone(),
      ...rest
    } = props;
    const wrapperRef = react.useRef(null);
    const lastError = react.useRef(false);
    const handleWrapperRef = core.useForkRef(ref, wrapperRef);
    const innerInputRef = react.useRef(null);
    const handleInputRef = core.useForkRef(
      innerInputRef,
      inputRefProp
    );
    const inputId = core.useId();
    const targetWindow = window.useWindow();
    styles.useComponentCssInjection({
      testId: "salt-date-input-single",
      css: DateInput,
      window: targetWindow
    });
    const [date$1, setDate] = core.useControlled({
      controlled: dateProp,
      default: defaultDate,
      name: "DateInputSingle",
      state: "date"
    });
    const [dateValue, setDateValue] = core.useControlled({
      controlled: valueProp,
      default: defaultValue,
      name: "DateInputSingle",
      state: "dateValue"
    });
    const preservedTime = react.useRef(
      utils.extractTimeFieldsFromDate(date$1 || null)
    );
    const format = react.useCallback(
      (date2) => {
        return formatProp ? formatProp(date2) : formatDate.formatDate(date2, locale, { timeZone });
      },
      [formatProp, locale, timeZone]
    );
    react.useEffect(() => {
      const formattedDate = format(date$1 || null);
      if (formattedDate) {
        setDateValue(formattedDate);
        onDateValueChange == null ? void 0 : onDateValueChange(formattedDate, true);
      }
    }, [date$1, format, locale, timeZone]);
    const [focused, setFocused] = react.useState(false);
    const {
      a11yProps: {
        "aria-describedby": formFieldDescribedBy,
        "aria-labelledby": formFieldLabelledBy
      } = {},
      disabled: formFieldDisabled,
      readOnly: formFieldReadOnly,
      necessity: formFieldRequired,
      validationStatus: formFieldValidationStatus
    } = core.useFormFieldProps();
    const isReadOnly = readOnlyProp || formFieldReadOnly;
    const isDisabled = disabled || formFieldDisabled;
    const validationStatus = formFieldValidationStatus != null ? formFieldValidationStatus : validationStatusProp;
    const {
      "aria-describedby": dateInputDescribedBy,
      "aria-labelledby": dateInputLabelledBy,
      onBlur: inputPropsOnBlur,
      onChange: inputPropsOnChange,
      onKeyDown: inputPropsOnKeyDown,
      onFocus: inputPropsOnFocus,
      required: dateInputPropsRequired,
      ...restDateInputProps
    } = inputProps;
    const isRequired = formFieldRequired ? ["required", "asterisk"].includes(formFieldRequired) : dateInputPropsRequired;
    const apply = (event) => {
      const { date: parsedDate, error } = parse(dateValue != null ? dateValue : "");
      let newDate = parsedDate;
      if (newDate) {
        const formattedDate = format(newDate);
        if (formattedDate) {
          setDateValue(formattedDate);
          onDateValueChange == null ? void 0 : onDateValueChange(formattedDate, true);
        }
      }
      const hasDateChanged = newDate && date$1 ? newDate.compare(date$1) !== 0 : newDate !== date$1;
      if (hasDateChanged) {
        setDate(newDate);
        if (newDate && preservedTime.current) {
          newDate = newDate.set(preservedTime.current);
        }
      }
      if (hasDateChanged || lastError.current !== error) {
        onDateChange == null ? void 0 : onDateChange(event, newDate, error);
      }
      lastError.current = error;
    };
    const handleChange = (event) => {
      const newDateValue = event.target.value;
      setDateValue(newDateValue);
      inputPropsOnChange == null ? void 0 : inputPropsOnChange(event);
      onChange == null ? void 0 : onChange(event);
      onDateValueChange == null ? void 0 : onDateValueChange(newDateValue, false);
    };
    const handleFocus = (event) => {
      setFocused(true);
      inputPropsOnFocus == null ? void 0 : inputPropsOnFocus(event);
    };
    const handleBlur = (event) => {
      setFocused(false);
      apply(event);
      inputPropsOnBlur == null ? void 0 : inputPropsOnBlur(event);
    };
    const handleKeyDown = (event) => {
      if (event.key === "Enter") {
        apply(event);
      }
      inputPropsOnKeyDown == null ? void 0 : inputPropsOnKeyDown(event);
    };
    const handleClick = (event) => {
      var _a;
      if (event.target === wrapperRef.current) {
        (_a = innerInputRef == null ? void 0 : innerInputRef.current) == null ? void 0 : _a.focus();
      }
      onClick == null ? void 0 : onClick(event);
    };
    return /* @__PURE__ */ jsxRuntime.jsxs("div", {
      className: clsx.clsx(
        withBaseName(),
        withBaseName(variant),
        {
          [withBaseName("focused")]: !isDisabled && focused,
          [withBaseName("disabled")]: isDisabled,
          [withBaseName("readOnly")]: isReadOnly,
          [withBaseName(validationStatus != null ? validationStatus : "")]: validationStatus,
          [withBaseName("bordered")]: bordered
        },
        className
      ),
      ref: handleWrapperRef,
      onClick: handleClick,
      ...rest,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx("input", {
          autoComplete: "off",
          "aria-describedby": clsx.clsx(formFieldDescribedBy, dateInputDescribedBy),
          "aria-labelledby": clsx.clsx(
            formFieldLabelledBy,
            dateInputLabelledBy,
            inputId
          ),
          "aria-label": clsx.clsx("Selected date", ariaLabel),
          id: inputId,
          className: withBaseName("input"),
          disabled: isDisabled,
          readOnly: isReadOnly,
          ref: handleInputRef,
          tabIndex: isDisabled ? -1 : 0,
          placeholder,
          size: placeholder.length,
          value: isReadOnly && !dateValue ? emptyReadOnlyMarker : dateValue,
          ...restDateInputProps,
          onBlur: handleBlur,
          onChange: handleChange,
          onKeyDown: handleKeyDown,
          onFocus: !isDisabled ? handleFocus : void 0,
          required: isRequired
        }),
        /* @__PURE__ */ jsxRuntime.jsxs("div", {
          className: withBaseName("endAdornmentContainer"),
          children: [
            !isDisabled && !isReadOnly && validationStatus && /* @__PURE__ */ jsxRuntime.jsx(core.StatusAdornment, {
              status: validationStatus
            }),
            endAdornment
          ]
        }),
        /* @__PURE__ */ jsxRuntime.jsx("div", {
          className: withBaseName("activationIndicator")
        })
      ]
    });
  }
);

exports.DateInputSingle = DateInputSingle;
//# sourceMappingURL=DateInputSingle.js.map
