{"version":3,"file":"utils.js","sources":["../src/date-input/utils.ts"],"sourcesContent":["import {\n  CalendarDate,\n  CalendarDateTime,\n  type DateValue,\n  type TimeFields,\n  ZonedDateTime,\n  getLocalTimeZone,\n  toZoned,\n} from \"@internationalized/date\";\nimport type { DateRangeSelection, SingleDateSelection } from \"../calendar\";\n\nexport type RangeTimeFields = {\n  startTime?: TimeFields;\n  endTime?: TimeFields;\n};\n\n/**\n * Parses a string into a CalendarDate.\n * @param inputDate - The input date string.\n * @returns An object containing the parsed date and any error encountered.\n */\nexport function parseCalendarDate(inputDate: string): {\n  date: DateValue | null;\n  error: string | false;\n} {\n  if (!inputDate?.length) {\n    return { date: null, error: false };\n  }\n  const date = new Date(inputDate);\n  if (Number.isNaN(date.getTime())) {\n    return { date: null, error: \"not a valid date\" };\n  }\n\n  const year = date.getFullYear();\n  const month = date.getMonth() + 1;\n  const day = date.getDate();\n\n  try {\n    const isoDate = new CalendarDate(year, month, day);\n    return { date: isoDate, error: false };\n  } catch (err) {\n    return { date: null, error: (err as Error).message };\n  }\n}\n\n/**\n * Parses a string into a ZonedDateTime.\n * @param inputDate - The input date string.\n * @param timeZone - The time zone to use for parsing. Defaults to the local time zone.\n * @returns An object containing the parsed date and any error encountered.\n */\nexport function parseZonedDateTime(\n  inputDate: string,\n  timeZone: string = getLocalTimeZone(),\n): {\n  date: DateValue | null;\n  error: string | false;\n} {\n  const parsedDate = parseCalendarDate(inputDate);\n  if (!parsedDate.date || parsedDate.error) {\n    return { ...parsedDate, date: null };\n  }\n  try {\n    const zonedDate = toZoned(parsedDate.date, timeZone, \"compatible\");\n    return { date: zonedDate, error: false };\n  } catch (err) {\n    return { date: null, error: (err as Error).message };\n  }\n}\n\n/**\n * Checks if a date supports time fields.\n * @param date - The date to check.\n * @returns `true` if the date supports time fields, otherwise `false`.\n */\nexport const dateSupportsTime = (\n  date: DateValue,\n): date is CalendarDateTime | ZonedDateTime =>\n  date instanceof CalendarDateTime || date instanceof ZonedDateTime;\n\n/**\n * Extracts time fields from a date range selection.\n * @param selectedDate - The selected date range.\n * @returns An object containing the start and end time fields.\n */\nexport function extractTimeFieldsFromDateRange(\n  selectedDate: DateRangeSelection | null,\n): RangeTimeFields {\n  let startTime: TimeFields | undefined;\n  let endTime: TimeFields | undefined;\n  if (selectedDate) {\n    if (selectedDate.startDate && dateSupportsTime(selectedDate.startDate)) {\n      const { hour, minute, second, millisecond } = selectedDate.startDate;\n      startTime = { hour, minute, second, millisecond };\n    }\n    if (selectedDate.endDate && dateSupportsTime(selectedDate.endDate)) {\n      const { hour, minute, second, millisecond } = selectedDate.endDate;\n      endTime = { hour, minute, second, millisecond };\n    }\n  }\n  return { startTime, endTime };\n}\n\n/**\n * Extracts time fields from a single date selection.\n * @param selectedDate - The selected date.\n * @returns The time fields of the selected date, if available.\n */\nexport function extractTimeFieldsFromDate(\n  selectedDate: SingleDateSelection | null,\n): TimeFields | undefined {\n  if (selectedDate && dateSupportsTime(selectedDate)) {\n    const { hour, minute, second, millisecond } = selectedDate;\n    return { hour, minute, second, millisecond };\n  }\n}\n"],"names":["date","CalendarDate","getLocalTimeZone","toZoned","CalendarDateTime","ZonedDateTime"],"mappings":"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"}