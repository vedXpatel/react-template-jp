'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var date = require('@internationalized/date');
var core = require('@salt-ds/core');
var styles = require('@salt-ds/styles');
var window = require('@salt-ds/window');
var clsx = require('clsx');
var react = require('react');
require('../calendar/Calendar.js');
require('../calendar/CalendarNavigation.js');
require('../calendar/CalendarWeekHeader.js');
require('../calendar/CalendarDateGrid.js');
require('../calendar/internal/CalendarContext.js');
var formatDate = require('../calendar/formatDate.js');
require('../calendar/useCalendarSelection.js');
var DateInput = require('./DateInput.css.js');
var utils = require('./utils.js');

const withBaseName = core.makePrefixer("saltDateInput");
const DateInputRange = react.forwardRef(
  function DateInputRange2(props, ref) {
    var _a, _b;
    const {
      bordered = false,
      className,
      disabled,
      "aria-label": ariaLabel,
      date: dateProp,
      defaultDate = {},
      onDateChange,
      value: valueProp,
      defaultValue = { startDate: "", endDate: "" },
      onChange,
      onClick,
      onDateValueChange,
      emptyReadOnlyMarker = "\u2014",
      endAdornment,
      format: formatProp,
      startInputProps = {},
      endInputProps = {},
      startInputRef: startInputRefProp,
      endInputRef: endInputRefProp,
      parse = utils.parseCalendarDate,
      placeholder = "dd mmm yyyy",
      readOnly: readOnlyProp,
      validationStatus: validationStatusProp,
      variant = "primary",
      locale = formatDate.getCurrentLocale(),
      timeZone = date.getLocalTimeZone(),
      ...rest
    } = props;
    const wrapperRef = react.useRef(null);
    const handleWrapperRef = core.useForkRef(ref, wrapperRef);
    const lastError = react.useRef({
      startDate: false,
      endDate: false
    });
    const startInputRef = react.useRef(null);
    const handleStartInputRef = core.useForkRef(startInputRef, startInputRefProp);
    const endInputRef = react.useRef(null);
    const handleEndInputRef = core.useForkRef(endInputRef, endInputRefProp);
    const startInputID = core.useId();
    const endInputID = core.useId();
    const targetWindow = window.useWindow();
    styles.useComponentCssInjection({
      testId: "salt-date-input-range",
      css: DateInput,
      window: targetWindow
    });
    const [date$1, setDate] = core.useControlled({
      controlled: dateProp,
      default: defaultDate,
      name: "DateInputRange",
      state: "date"
    });
    const [dateValue, setDateValue] = core.useControlled({
      controlled: valueProp,
      default: defaultValue,
      name: "DateInputRange",
      state: "dateValue"
    });
    const preservedTime = react.useRef({});
    preservedTime.current = utils.extractTimeFieldsFromDateRange(date$1);
    const format = react.useCallback(
      (date2) => {
        return formatProp ? formatProp(date2) : formatDate.formatDate(date2, locale, { timeZone });
      },
      [formatProp, locale, timeZone]
    );
    const setDateValueFromDate = (newDate) => {
      var _a2, _b2;
      let newDateValue = { ...dateValue };
      const formattedStartDate = format((_a2 = newDate == null ? void 0 : newDate.startDate) != null ? _a2 : null);
      if (formattedStartDate) {
        newDateValue = { ...newDateValue, startDate: formattedStartDate };
      }
      const formattedEndDate = format((_b2 = newDate == null ? void 0 : newDate.endDate) != null ? _b2 : null);
      if (formattedEndDate) {
        newDateValue = { ...newDateValue, endDate: formattedEndDate };
      }
      if ((newDateValue == null ? void 0 : newDateValue.startDate) !== (dateValue == null ? void 0 : dateValue.startDate) || (newDateValue == null ? void 0 : newDateValue.endDate) !== (dateValue == null ? void 0 : dateValue.endDate)) {
        onDateValueChange == null ? void 0 : onDateValueChange(newDateValue, true);
      }
      setDateValue(newDateValue);
    };
    react.useEffect(() => {
      setDateValueFromDate(date$1);
    }, [date$1, date$1 == null ? void 0 : date$1.startDate, date$1 == null ? void 0 : date$1.endDate]);
    const [focused, setFocused] = react.useState(false);
    const {
      a11yProps: {
        "aria-describedby": formFieldDescribedBy,
        "aria-labelledby": formFieldLabelledBy
      } = {},
      disabled: formFieldDisabled,
      readOnly: formFieldReadOnly,
      necessity: formFieldRequired,
      validationStatus: formFieldValidationStatus
    } = core.useFormFieldProps();
    const isReadOnly = readOnlyProp || formFieldReadOnly;
    const isDisabled = disabled || formFieldDisabled;
    const validationStatus = formFieldValidationStatus != null ? formFieldValidationStatus : validationStatusProp;
    const {
      "aria-describedby": startInputPropsDescribedBy,
      "aria-labelledby": startInputPropsLabelledBy,
      onBlur: startInputPropsOnBlur,
      onChange: startInputPropsOnChange,
      onKeyDown: startInputPropsOnKeyDown,
      onFocus: startInputPropsOnFocus,
      required: startInputPropsRequired,
      ...restStartInputProps
    } = startInputProps;
    const startInputIsRequired = formFieldRequired ? ["required", "asterisk"].includes(formFieldRequired) : startInputPropsRequired;
    const {
      "aria-describedby": endInputPropsDescribedBy,
      "aria-labelledby": endInputPropsLabelledBy,
      onBlur: endInputPropsOnBlur,
      onChange: endInputPropsOnChange,
      onKeyDown: endInputPropsOnKeyDown,
      onFocus: endInputPropsOnFocus,
      required: endInputPropsRequired,
      ...restEndInputProps
    } = endInputProps;
    const endInputIsRequired = formFieldRequired ? ["required", "asterisk"].includes(formFieldRequired) : endInputPropsRequired;
    const apply = (event) => {
      var _a2;
      const { date: newStartDate, error: startDateError } = parse(
        (_a2 = dateValue.startDate) != null ? _a2 : ""
      );
      const { date: newEndDate, error: endDateError } = parse(
        dateValue.endDate || ""
      );
      const hasDateChanged = (newDate2, oldDate) => {
        if (newDate2 && oldDate) {
          return newDate2.compare(oldDate) !== 0;
        }
        return newDate2 !== oldDate;
      };
      const createNewDateRange = (startDate, endDate) => {
        if (!startDate && !endDate) {
          return null;
        }
        const dateRange = {};
        dateRange.startDate = startDate;
        dateRange.endDate = endDate;
        return dateRange;
      };
      const hasStartDateChanged = hasDateChanged(
        newStartDate,
        (date$1 == null ? void 0 : date$1.startDate) || null
      );
      const hasEndDateChanged = hasDateChanged(
        newEndDate,
        (date$1 == null ? void 0 : date$1.endDate) || null
      );
      const hasStartOrEndDateChanged = hasStartDateChanged || hasEndDateChanged;
      const newDate = createNewDateRange(
        newStartDate,
        newEndDate
      );
      if ((newDate == null ? void 0 : newDate.startDate) || (newDate == null ? void 0 : newDate.endDate)) {
        setDateValueFromDate(newDate);
      }
      if (hasStartOrEndDateChanged) {
        setDate(newDate);
        if ((newDate == null ? void 0 : newDate.startDate) && preservedTime.current.startTime) {
          newDate.startDate = newDate.startDate.set(
            preservedTime.current.startTime
          );
        }
        if ((newDate == null ? void 0 : newDate.endDate) && preservedTime.current.endTime) {
          newDate.endDate = newDate.endDate.set(preservedTime.current.endTime);
        }
      }
      const error = {
        startDate: startDateError,
        endDate: endDateError
      };
      if (hasStartOrEndDateChanged || lastError.current.startDate !== error.startDate || lastError.current.endDate !== error.endDate) {
        const error2 = {
          startDate: startDateError,
          endDate: endDateError
        };
        onDateChange == null ? void 0 : onDateChange(event, newDate, error2);
        lastError.current = error2;
      }
    };
    const handleStartInputChange = (event) => {
      const newDateValue = { ...dateValue, startDate: event.target.value };
      setDateValue(newDateValue);
      startInputPropsOnChange == null ? void 0 : startInputPropsOnChange(event);
      onChange == null ? void 0 : onChange(event, newDateValue);
      onDateValueChange == null ? void 0 : onDateValueChange(newDateValue, false);
    };
    const handleEndInputChange = (event) => {
      const newDateValue = { ...dateValue, endDate: event.target.value };
      setDateValue(newDateValue);
      endInputPropsOnChange == null ? void 0 : endInputPropsOnChange(event);
      onChange == null ? void 0 : onChange(event, newDateValue);
      onDateValueChange == null ? void 0 : onDateValueChange(newDateValue, false);
    };
    const handleStartInputFocus = (event) => {
      setFocused(true);
      startInputPropsOnFocus == null ? void 0 : startInputPropsOnFocus(event);
    };
    const handleEndInputFocus = (event) => {
      setFocused(true);
      endInputPropsOnFocus == null ? void 0 : endInputPropsOnFocus(event);
    };
    const handleStartInputBlur = (event) => {
      setFocused(false);
      apply(event);
      startInputPropsOnBlur == null ? void 0 : startInputPropsOnBlur(event);
    };
    const handleEndInputBlur = (event) => {
      setFocused(false);
      apply(event);
      endInputPropsOnBlur == null ? void 0 : endInputPropsOnBlur(event);
    };
    const handleStartInputKeyDown = (event) => {
      if (event.key === "Enter") {
        apply(event);
      }
      startInputPropsOnKeyDown == null ? void 0 : startInputPropsOnKeyDown(event);
    };
    const handleEndInputKeyDown = (event) => {
      if (event.key === "Enter") {
        apply(event);
      }
      endInputPropsOnKeyDown == null ? void 0 : endInputPropsOnKeyDown(event);
    };
    const handleWrapperClick = (event) => {
      if (event.target === wrapperRef.current) {
        const input = startInputRef.current;
        input == null ? void 0 : input.focus();
        input == null ? void 0 : input.setSelectionRange(input.value.length, input.value.length);
      }
      onClick == null ? void 0 : onClick(event);
    };
    return /* @__PURE__ */ jsxRuntime.jsxs("div", {
      className: clsx.clsx(
        withBaseName(),
        withBaseName(variant),
        {
          [withBaseName("focused")]: !isDisabled && focused,
          [withBaseName("disabled")]: isDisabled,
          [withBaseName("readOnly")]: isReadOnly,
          [withBaseName(validationStatus != null ? validationStatus : "")]: validationStatus,
          [withBaseName("bordered")]: bordered
        },
        className
      ),
      ref: handleWrapperRef,
      onClick: handleWrapperClick,
      ...rest,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx("input", {
          autoComplete: "off",
          "aria-describedby": clsx.clsx(
            formFieldDescribedBy,
            startInputPropsDescribedBy
          ),
          "aria-labelledby": clsx.clsx(
            formFieldLabelledBy,
            startInputPropsLabelledBy,
            startInputID
          ),
          "aria-label": clsx.clsx("Start date", ariaLabel),
          id: startInputID,
          className: withBaseName("input"),
          disabled: isDisabled,
          readOnly: isReadOnly,
          ref: handleStartInputRef,
          tabIndex: isDisabled ? -1 : 0,
          placeholder,
          size: placeholder.length,
          value: isReadOnly && !(dateValue == null ? void 0 : dateValue.startDate) ? emptyReadOnlyMarker : (_a = dateValue.startDate) != null ? _a : "",
          ...restStartInputProps,
          onBlur: handleStartInputBlur,
          onChange: handleStartInputChange,
          onKeyDown: handleStartInputKeyDown,
          onFocus: !isDisabled ? handleStartInputFocus : void 0,
          required: startInputIsRequired
        }),
        /* @__PURE__ */ jsxRuntime.jsx("span", {
          children: "-"
        }),
        /* @__PURE__ */ jsxRuntime.jsx("input", {
          autoComplete: "off",
          "aria-describedby": clsx.clsx(
            formFieldDescribedBy,
            endInputPropsDescribedBy
          ),
          "aria-labelledby": clsx.clsx(
            formFieldLabelledBy,
            endInputPropsLabelledBy,
            endInputID
          ),
          "aria-label": clsx.clsx("End date", ariaLabel),
          id: endInputID,
          className: withBaseName("input"),
          disabled: isDisabled,
          readOnly: isReadOnly,
          ref: handleEndInputRef,
          tabIndex: isDisabled ? -1 : 0,
          placeholder,
          size: placeholder.length,
          value: isReadOnly && !(dateValue == null ? void 0 : dateValue.endDate) ? emptyReadOnlyMarker : (_b = dateValue.endDate) != null ? _b : "",
          ...restEndInputProps,
          onBlur: handleEndInputBlur,
          onChange: handleEndInputChange,
          onKeyDown: handleEndInputKeyDown,
          onFocus: !isDisabled ? handleEndInputFocus : void 0,
          required: endInputIsRequired
        }),
        /* @__PURE__ */ jsxRuntime.jsxs("div", {
          className: withBaseName("endAdornmentContainer"),
          children: [
            !isDisabled && !isReadOnly && validationStatus && /* @__PURE__ */ jsxRuntime.jsx(core.StatusAdornment, {
              status: validationStatus
            }),
            endAdornment
          ]
        }),
        /* @__PURE__ */ jsxRuntime.jsx("div", {
          className: withBaseName("activationIndicator")
        })
      ]
    });
  }
);

exports.DateInputRange = DateInputRange;
//# sourceMappingURL=DateInputRange.js.map
